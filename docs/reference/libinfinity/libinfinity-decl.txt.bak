<STRUCT>
<NAME>InfcNotePlugin</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcNotePlugin</NAME>
struct _InfcNotePlugin {
  const gchar* note_type;

  InfSession*(*session_new)(InfIo* io,
                            InfConnectionManager* manager,
                            InfConnectionManagerGroup* sync_group,
                            InfXmlConnection* sync_connection);
};

</STRUCT>
<MACRO>
<NAME>INFC_TYPE_BROWSER</NAME>
#define INFC_TYPE_BROWSER                 (infc_browser_get_type())
</MACRO>
<MACRO>
<NAME>INFC_BROWSER</NAME>
#define INFC_BROWSER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFC_TYPE_BROWSER, InfcBrowser))
</MACRO>
<MACRO>
<NAME>INFC_BROWSER_CLASS</NAME>
#define INFC_BROWSER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFC_TYPE_BROWSER, InfcBrowserClass))
</MACRO>
<MACRO>
<NAME>INFC_IS_BROWSER</NAME>
#define INFC_IS_BROWSER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFC_TYPE_BROWSER))
</MACRO>
<MACRO>
<NAME>INFC_IS_BROWSER_CLASS</NAME>
#define INFC_IS_BROWSER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFC_TYPE_BROWSER))
</MACRO>
<MACRO>
<NAME>INFC_BROWSER_GET_CLASS</NAME>
#define INFC_BROWSER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFC_TYPE_BROWSER, InfcBrowserClass))
</MACRO>
<STRUCT>
<NAME>InfcBrowser</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcBrowserClass</NAME>
</STRUCT>
<ENUM>
<NAME>InfcBrowserNodeStatus</NAME>
typedef enum _InfcBrowserNodeStatus {
  /* The node is synchronized with the server */
  INFC_BROWSER_NODE_SYNC,
  /* The node has been deleted locally, but the server has not yet
   * acknowledged the deletion and might still reject the request. */
  INFC_BROWSER_NODE_DELETED,
  /* The node has been added locally, but the server has not yet
   * acknowledged the addition and might still reject the request. */
  INFC_BROWSER_NODE_ADDED,
  /* The node has been moved locally, but the server has not yet
   * acknowledged the move and might still reject the request. */
  INFC_BROWSER_NODE_MOVED,
  /* The node has been copied locally, but the server has not yet
   * acknowledget the copy and might still reject the request. */
  INFC_BROWSER_NODE_COPIED,
  /* Inherit status from parent node (used internally) */
  INFC_BROWSER_NODE_INHERIT
} InfcBrowserNodeStatus;
</ENUM>
<STRUCT>
<NAME>InfcBrowserClass</NAME>
struct _InfcBrowserClass {
  GObjectClass parent_class;

  /* Signals */
  void (*node_added)(InfcBrowser* browser,
                     InfcBrowserIter* iter);

  void (*node_removed)(InfcBrowser* browser,
                       InfcBrowserIter* iter);

  void (*begin_explore)(InfcBrowser* browser,
                        InfcBrowserIter* iter,
                        InfcExploreRequest* request);

  void (*begin_subscribe)(InfcBrowser* browser,
                          InfcBrowserIter* iter,
                          InfcNodeRequest* request);

  void (*subscribe_session)(InfcBrowser* browser,
                            InfcBrowserIter* iter,
                            InfcSessionProxy* proxy);
};

</STRUCT>
<STRUCT>
<NAME>InfcBrowser</NAME>
struct _InfcBrowser {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>infc_browser_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_new</NAME>
<RETURNS>InfcBrowser *</RETURNS>
InfIo* io,InfConnectionManager* connection_manager,InfMethodManager* method_manager,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_get_connection_manager</NAME>
<RETURNS>InfConnectionManager *</RETURNS>
InfcBrowser* browser
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_get_connection</NAME>
<RETURNS>InfXmlConnection *</RETURNS>
InfcBrowser* browser
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_add_plugin</NAME>
<RETURNS>gboolean </RETURNS>
InfcBrowser* browser,const InfcNotePlugin* plugin
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_lookup_plugin</NAME>
<RETURNS>const InfcNotePlugin *</RETURNS>
InfcBrowser* browser,const gchar* note_type
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_root</NAME>
<RETURNS>void </RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_next</NAME>
<RETURNS>gboolean </RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_prev</NAME>
<RETURNS>gboolean </RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_parent</NAME>
<RETURNS>gboolean </RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_explored</NAME>
<RETURNS>gboolean </RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_explore_request</NAME>
<RETURNS>InfcExploreRequest *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_from_explore_request</NAME>
<RETURNS>gboolean </RETURNS>
InfcBrowser* browser,InfcExploreRequest* request,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_child</NAME>
<RETURNS>gboolean </RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_explore</NAME>
<RETURNS>InfcExploreRequest *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_is_subdirectory</NAME>
<RETURNS>gboolean </RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_add_subdirectory</NAME>
<RETURNS>InfcNodeRequest *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* parent,const gchar* name
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_add_note</NAME>
<RETURNS>InfcNodeRequest *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* parent,const gchar* name,const InfcNotePlugin* plugin
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_remove_node</NAME>
<RETURNS>InfcNodeRequest *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_note_type</NAME>
<RETURNS>const gchar *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_plugin</NAME>
<RETURNS>const InfcNotePlugin *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_subscribe_session</NAME>
<RETURNS>InfcNodeRequest *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_save_session</NAME>
<RETURNS>InfcNodeRequest *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_session</NAME>
<RETURNS>InfcSessionProxy *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_get_subscribe_request</NAME>
<RETURNS>InfcNodeRequest *</RETURNS>
InfcBrowser* browser,InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_from_node_request</NAME>
<RETURNS>gboolean </RETURNS>
InfcBrowser* browser,InfcNodeRequest* request,InfcBrowserIter* iter
</FUNCTION>
<MACRO>
<NAME>INFC_TYPE_EXPLORE_REQUEST</NAME>
#define INFC_TYPE_EXPLORE_REQUEST                 (infc_explore_request_get_type())
</MACRO>
<MACRO>
<NAME>INFC_EXPLORE_REQUEST</NAME>
#define INFC_EXPLORE_REQUEST(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFC_TYPE_EXPLORE_REQUEST, InfcExploreRequest))
</MACRO>
<MACRO>
<NAME>INFC_EXPLORE_REQUEST_CLASS</NAME>
#define INFC_EXPLORE_REQUEST_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFC_TYPE_EXPLORE_REQUEST, InfcExploreRequestClass))
</MACRO>
<MACRO>
<NAME>INFC_IS_EXPLORE_REQUEST</NAME>
#define INFC_IS_EXPLORE_REQUEST(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFC_TYPE_EXPLORE_REQUEST))
</MACRO>
<MACRO>
<NAME>INFC_IS_EXPLORE_REQUEST_CLASS</NAME>
#define INFC_IS_EXPLORE_REQUEST_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFC_TYPE_EXPLORE_REQUEST))
</MACRO>
<MACRO>
<NAME>INFC_EXPLORE_REQUEST_GET_CLASS</NAME>
#define INFC_EXPLORE_REQUEST_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFC_TYPE_EXPLORE_REQUEST, InfcExploreRequestClass))
</MACRO>
<STRUCT>
<NAME>InfcExploreRequest</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcExploreRequestClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcExploreRequestClass</NAME>
struct _InfcExploreRequestClass {
  InfcRequestClass parent_class;

  /* Signals */
  void (*initiated)(InfcExploreRequest *explore_request,
                    guint total);
  void (*progress)(InfcExploreRequest* explore_request,
                   guint current,
                   guint total);
  void (*finished)(InfcExploreRequest* explore_request);
};

</STRUCT>
<STRUCT>
<NAME>InfcExploreRequest</NAME>
struct _InfcExploreRequest {
  InfcRequest parent;
};

</STRUCT>
<FUNCTION>
<NAME>infc_explore_request_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infc_explore_request_get_node_id</NAME>
<RETURNS>guint </RETURNS>
InfcExploreRequest* request
</FUNCTION>
<FUNCTION>
<NAME>infc_explore_request_initiated</NAME>
<RETURNS>void </RETURNS>
InfcExploreRequest* request,guint total
</FUNCTION>
<FUNCTION>
<NAME>infc_explore_request_progress</NAME>
<RETURNS>gboolean </RETURNS>
InfcExploreRequest* request,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infc_explore_request_finished</NAME>
<RETURNS>gboolean </RETURNS>
InfcExploreRequest* request,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infc_explore_request_get_initiated</NAME>
<RETURNS>gboolean </RETURNS>
InfcExploreRequest* request
</FUNCTION>
<FUNCTION>
<NAME>infc_explore_request_get_finished</NAME>
<RETURNS>gboolean </RETURNS>
InfcExploreRequest* request
</FUNCTION>
<MACRO>
<NAME>INFC_TYPE_NODE_REQUEST</NAME>
#define INFC_TYPE_NODE_REQUEST                 (infc_node_request_get_type())
</MACRO>
<MACRO>
<NAME>INFC_NODE_REQUEST</NAME>
#define INFC_NODE_REQUEST(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFC_TYPE_NODE_REQUEST, InfcNodeRequest))
</MACRO>
<MACRO>
<NAME>INFC_NODE_REQUEST_CLASS</NAME>
#define INFC_NODE_REQUEST_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFC_TYPE_NODE_REQUEST, InfcNodeRequestClass))
</MACRO>
<MACRO>
<NAME>INFC_IS_NODE_REQUEST</NAME>
#define INFC_IS_NODE_REQUEST(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFC_TYPE_NODE_REQUEST))
</MACRO>
<MACRO>
<NAME>INFC_IS_NODE_REQUEST_CLASS</NAME>
#define INFC_IS_NODE_REQUEST_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFC_TYPE_NODE_REQUEST))
</MACRO>
<MACRO>
<NAME>INFC_NODE_REQUEST_GET_CLASS</NAME>
#define INFC_NODE_REQUEST_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFC_TYPE_NODE_REQUEST, InfcNodeRequestClass))
</MACRO>
<STRUCT>
<NAME>InfcNodeRequest</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcNodeRequestClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcNodeRequestClass</NAME>
struct _InfcNodeRequestClass {
  InfcRequestClass parent_class;

  /* Signals */
  void (*finished)(InfcNodeRequest* node_request,
                   const InfcBrowserIter* iter);
};

</STRUCT>
<STRUCT>
<NAME>InfcNodeRequest</NAME>
struct _InfcNodeRequest {
  InfcRequest parent;
};

</STRUCT>
<FUNCTION>
<NAME>infc_node_request_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infc_node_request_finished</NAME>
<RETURNS>void </RETURNS>
InfcNodeRequest* request,const InfcBrowserIter* iter
</FUNCTION>
<MACRO>
<NAME>INFC_TYPE_REQUEST_MANAGER</NAME>
#define INFC_TYPE_REQUEST_MANAGER                 (infc_request_manager_get_type())
</MACRO>
<MACRO>
<NAME>INFC_REQUEST_MANAGER</NAME>
#define INFC_REQUEST_MANAGER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFC_TYPE_REQUEST_MANAGER, InfcRequestManager))
</MACRO>
<MACRO>
<NAME>INFC_REQUEST_MANAGER_CLASS</NAME>
#define INFC_REQUEST_MANAGER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFC_TYPE_REQUEST_MANAGER, InfcRequestManagerClass))
</MACRO>
<MACRO>
<NAME>INFC_IS_REQUEST_MANAGER</NAME>
#define INFC_IS_REQUEST_MANAGER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFC_TYPE_REQUEST_MANAGER))
</MACRO>
<MACRO>
<NAME>INFC_IS_REQUEST_MANAGER_CLASS</NAME>
#define INFC_IS_REQUEST_MANAGER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFC_TYPE_REQUEST_MANAGER))
</MACRO>
<MACRO>
<NAME>INFC_REQUEST_MANAGER_GET_CLASS</NAME>
#define INFC_REQUEST_MANAGER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFC_TYPE_REQUEST_MANAGER, InfcRequestManagerClass))
</MACRO>
<STRUCT>
<NAME>InfcRequestManager</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcRequestManagerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcRequestManagerClass</NAME>
struct _InfcRequestManagerClass {
  GObjectClass parent_class;

  void (*request_add)(InfcRequestManager* manager,
                      InfcRequest* request);
  void (*request_remove)(InfcRequestManager* manager,
                         InfcRequest* request);
};

</STRUCT>
<STRUCT>
<NAME>InfcRequestManager</NAME>
struct _InfcRequestManager {
  GObject parent;
};

</STRUCT>
<USER_FUNCTION>
<NAME>InfcRequestManagerForeachFunc</NAME>
<RETURNS>void </RETURNS>
InfcRequest*, gpointer
</USER_FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_new</NAME>
<RETURNS>InfcRequestManager *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_add_request</NAME>
<RETURNS>InfcRequest *</RETURNS>
InfcRequestManager* manager,GType request_type,const gchar* request_name,const gchar* first_property_name,...
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_add_request_valist</NAME>
<RETURNS>InfcRequest *</RETURNS>
InfcRequestManager* manager,GType request_type,const gchar* request_name,const gchar* first_property_name,va_list arglist
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_remove_request</NAME>
<RETURNS>void </RETURNS>
InfcRequestManager* manager,InfcRequest* request
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_fail_request</NAME>
<RETURNS>void </RETURNS>
InfcRequestManager* manager,InfcRequest* request,GError* error
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_clear</NAME>
<RETURNS>void </RETURNS>
InfcRequestManager* manager
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_get_request_by_seq</NAME>
<RETURNS>InfcRequest *</RETURNS>
InfcRequestManager* manager,guint seq
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_get_request_by_xml</NAME>
<RETURNS>InfcRequest *</RETURNS>
InfcRequestManager* manager,const gchar* name,xmlNodePtr xml,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_get_request_by_xml_required</NAME>
<RETURNS>InfcRequest *</RETURNS>
InfcRequestManager* manager,const gchar* name,xmlNodePtr xml,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_foreach_request</NAME>
<RETURNS>void </RETURNS>
InfcRequestManager* manager,InfcRequestManagerForeachFunc func,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>infc_request_manager_foreach_named_request</NAME>
<RETURNS>void </RETURNS>
InfcRequestManager* manager,const gchar* name,InfcRequestManagerForeachFunc func,gpointer user_data
</FUNCTION>
<MACRO>
<NAME>INFC_TYPE_SESSION_PROXY</NAME>
#define INFC_TYPE_SESSION_PROXY                 (infc_session_proxy_get_type())
</MACRO>
<MACRO>
<NAME>INFC_SESSION_PROXY</NAME>
#define INFC_SESSION_PROXY(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFC_TYPE_SESSION_PROXY, InfcSessionProxy))
</MACRO>
<MACRO>
<NAME>INFC_SESSION_PROXY_CLASS</NAME>
#define INFC_SESSION_PROXY_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFC_TYPE_SESSION_PROXY, InfcSessionProxyClass))
</MACRO>
<MACRO>
<NAME>INFC_IS_SESSION_PROXY</NAME>
#define INFC_IS_SESSION_PROXY(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFC_TYPE_SESSION_PROXY))
</MACRO>
<MACRO>
<NAME>INFC_IS_SESSION_PROXY_CLASS</NAME>
#define INFC_IS_SESSION_PROXY_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFC_TYPE_SESSION_PROXY))
</MACRO>
<MACRO>
<NAME>INFC_SESSION_PROXY_GET_CLASS</NAME>
#define INFC_SESSION_PROXY_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFC_TYPE_SESSION_PROXY, InfcSessionProxyClass))
</MACRO>
<STRUCT>
<NAME>InfcSessionProxy</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcSessionProxyClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcSessionProxyClass</NAME>
struct _InfcSessionProxyClass {
  GObjectClass parent_class;

  GError* (*translate_error)(InfcSessionProxy* session,
                             GQuark domain,
                             guint code);
};

</STRUCT>
<STRUCT>
<NAME>InfcSessionProxy</NAME>
struct _InfcSessionProxy {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>infc_session_proxy_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infc_session_proxy_set_connection</NAME>
<RETURNS>void </RETURNS>
InfcSessionProxy* proxy,InfConnectionManagerGroup* group,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>infc_session_proxy_join_user</NAME>
<RETURNS>InfcUserRequest *</RETURNS>
InfcSessionProxy* proxy,const GParameter* params,guint n_params,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infc_session_proxy_leave_user</NAME>
<RETURNS>InfcUserRequest *</RETURNS>
InfcSessionProxy* proxy,InfUser* user,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infc_session_proxy_get_session</NAME>
<RETURNS>InfSession *</RETURNS>
InfcSessionProxy* proxy
</FUNCTION>
<MACRO>
<NAME>INFC_TYPE_BROWSER_ITER</NAME>
#define INFC_TYPE_BROWSER_ITER            (infc_browser_iter_get_type())
</MACRO>
<STRUCT>
<NAME>InfcBrowserIter</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcBrowserIter</NAME>
struct _InfcBrowserIter {
  guint node_id;
  gpointer node;
};

</STRUCT>
<FUNCTION>
<NAME>infc_browser_iter_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_copy</NAME>
<RETURNS>InfcBrowserIter *</RETURNS>
InfcBrowserIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infc_browser_iter_free</NAME>
<RETURNS>void </RETURNS>
InfcBrowserIter* iter
</FUNCTION>
<MACRO>
<NAME>INFC_TYPE_REQUEST</NAME>
#define INFC_TYPE_REQUEST                 (infc_request_get_type())
</MACRO>
<MACRO>
<NAME>INFC_REQUEST</NAME>
#define INFC_REQUEST(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFC_TYPE_REQUEST, InfcRequest))
</MACRO>
<MACRO>
<NAME>INFC_REQUEST_CLASS</NAME>
#define INFC_REQUEST_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFC_TYPE_REQUEST, InfcRequestClass))
</MACRO>
<MACRO>
<NAME>INFC_IS_REQUEST</NAME>
#define INFC_IS_REQUEST(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFC_TYPE_REQUEST))
</MACRO>
<MACRO>
<NAME>INFC_IS_REQUEST_CLASS</NAME>
#define INFC_IS_REQUEST_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFC_TYPE_REQUEST))
</MACRO>
<MACRO>
<NAME>INFC_REQUEST_GET_CLASS</NAME>
#define INFC_REQUEST_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFC_TYPE_REQUEST, InfcRequestClass))
</MACRO>
<STRUCT>
<NAME>InfcRequest</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcRequestClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcRequestClass</NAME>
struct _InfcRequestClass {
  GObjectClass parent_class;

  /* Signals */
  void (*failed)(InfcRequest* request, GError* error);

  void (*unused1)(void);
  void (*usused2)(void);
};

</STRUCT>
<STRUCT>
<NAME>InfcRequest</NAME>
struct _InfcRequest {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>infc_request_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infc_request_get_seq</NAME>
<RETURNS>guint </RETURNS>
InfcRequest* request
</FUNCTION>
<FUNCTION>
<NAME>infc_request_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
InfcRequest* request
</FUNCTION>
<FUNCTION>
<NAME>infc_request_failed</NAME>
<RETURNS>void </RETURNS>
InfcRequest* request,GError* error
</FUNCTION>
<MACRO>
<NAME>INFC_TYPE_USER_REQUEST</NAME>
#define INFC_TYPE_USER_REQUEST                 (infc_user_request_get_type())
</MACRO>
<MACRO>
<NAME>INFC_USER_REQUEST</NAME>
#define INFC_USER_REQUEST(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFC_TYPE_USER_REQUEST, InfcUserRequest))
</MACRO>
<MACRO>
<NAME>INFC_USER_REQUEST_CLASS</NAME>
#define INFC_USER_REQUEST_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFC_TYPE_USER_REQUEST, InfcUserRequestClass))
</MACRO>
<MACRO>
<NAME>INFC_IS_USER_REQUEST</NAME>
#define INFC_IS_USER_REQUEST(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFC_TYPE_USER_REQUEST))
</MACRO>
<MACRO>
<NAME>INFC_IS_USER_REQUEST_CLASS</NAME>
#define INFC_IS_USER_REQUEST_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFC_TYPE_USER_REQUEST))
</MACRO>
<MACRO>
<NAME>INFC_USER_REQUEST_GET_CLASS</NAME>
#define INFC_USER_REQUEST_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFC_TYPE_USER_REQUEST, InfcUserRequestClass))
</MACRO>
<STRUCT>
<NAME>InfcUserRequest</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcUserRequestClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfcUserRequestClass</NAME>
struct _InfcUserRequestClass {
  InfcRequestClass parent_class;

  /* Signals */
  void (*finished)(InfcUserRequest* request,
                   InfUser* user);
};

</STRUCT>
<STRUCT>
<NAME>InfcUserRequest</NAME>
struct _InfcUserRequest {
  InfcRequest parent;
};

</STRUCT>
<FUNCTION>
<NAME>infc_user_request_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infc_user_request_finished</NAME>
<RETURNS>void </RETURNS>
InfcUserRequest* request,InfUser* user
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_LOCAL_PUBLISHER</NAME>
#define INF_TYPE_LOCAL_PUBLISHER                 (inf_local_publisher_get_type())
</MACRO>
<MACRO>
<NAME>INF_LOCAL_PUBLISHER</NAME>
#define INF_LOCAL_PUBLISHER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_LOCAL_PUBLISHER, InfLocalPublisher))
</MACRO>
<MACRO>
<NAME>INF_IS_LOCAL_PUBLISHER</NAME>
#define INF_IS_LOCAL_PUBLISHER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_LOCAL_PUBLISHER))
</MACRO>
<MACRO>
<NAME>INF_LOCAL_PUBLISHER_GET_IFACE</NAME>
#define INF_LOCAL_PUBLISHER_GET_IFACE(inst)      (G_TYPE_INSTANCE_GET_INTERFACE((inst), INF_TYPE_LOCAL_PUBLISHER, InfLocalPublisherIface))
</MACRO>
<STRUCT>
<NAME>InfLocalPublisher</NAME>
</STRUCT>
<STRUCT>
<NAME>InfLocalPublisherIface</NAME>
</STRUCT>
<STRUCT>
<NAME>InfLocalPublisherItem</NAME>
</STRUCT>
<STRUCT>
<NAME>InfLocalPublisherIface</NAME>
struct _InfLocalPublisherIface {
  GTypeInterface parent;

  /* Virtual table */
  InfLocalPublisherItem* (*publish)(InfLocalPublisher* publisher,
                                    const gchar* type,
                                    const gchar* name,
                                    guint port);

  void (*unpublish)(InfLocalPublisher* publisher,
                    InfLocalPublisherItem* item);
};

</STRUCT>
<FUNCTION>
<NAME>inf_local_publisher_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_local_publisher_publish</NAME>
<RETURNS>InfLocalPublisherItem *</RETURNS>
InfLocalPublisher* publisher,const gchar* type,const gchar* name,guint port
</FUNCTION>
<FUNCTION>
<NAME>inf_local_publisher_unpublish</NAME>
<RETURNS>void </RETURNS>
InfLocalPublisher* publisher,InfLocalPublisherItem* item
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_TCP_CONNECTION</NAME>
#define INF_TYPE_TCP_CONNECTION                 (inf_tcp_connection_get_type())
</MACRO>
<MACRO>
<NAME>INF_TCP_CONNECTION</NAME>
#define INF_TCP_CONNECTION(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_TCP_CONNECTION, InfTcpConnection))
</MACRO>
<MACRO>
<NAME>INF_TCP_CONNECTION_CLASS</NAME>
#define INF_TCP_CONNECTION_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_TYPE_TCP_CONNECTION, InfTcpConnectionClass))
</MACRO>
<MACRO>
<NAME>INF_IS_TCP_CONNECTION</NAME>
#define INF_IS_TCP_CONNECTION(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_TCP_CONNECTION))
</MACRO>
<MACRO>
<NAME>INF_IS_TCP_CONNECTION_CLASS</NAME>
#define INF_IS_TCP_CONNECTION_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_TYPE_TCP_CONNECTION))
</MACRO>
<MACRO>
<NAME>INF_TCP_CONNECTION_GET_CLASS</NAME>
#define INF_TCP_CONNECTION_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_TYPE_TCP_CONNECTION, InfTcpConnectionClass))
</MACRO>
<MACRO>
<NAME>INF_TYPE_TCP_CONNECTION_STATUS</NAME>
#define INF_TYPE_TCP_CONNECTION_STATUS          (inf_tcp_connection_status_get_type())
</MACRO>
<STRUCT>
<NAME>InfTcpConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>InfTcpConnectionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfTcpConnectionClass</NAME>
struct _InfTcpConnectionClass {
  GObjectClass parent_class;

  /* Signals */
  void (*sent)(InfTcpConnection* connection,
               gconstpointer data,
               guint len);

  void (*received)(InfTcpConnection* connection,
                   gconstpointer data,
                   guint len);

  void (*error)(InfTcpConnection* connection,
                GError* error);
};

</STRUCT>
<STRUCT>
<NAME>InfTcpConnection</NAME>
struct _InfTcpConnection {
  GObject parent;
};

</STRUCT>
<ENUM>
<NAME>InfTcpConnectionStatus</NAME>
typedef enum _InfTcpConnectionStatus {
  INF_TCP_CONNECTION_CONNECTING,
  INF_TCP_CONNECTION_CONNECTED,
  INF_TCP_CONNECTION_CLOSED
} InfTcpConnectionStatus;
</ENUM>
<FUNCTION>
<NAME>inf_tcp_connection_status_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_tcp_connection_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_tcp_connection_open</NAME>
<RETURNS>gboolean </RETURNS>
InfTcpConnection* connection,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_tcp_connection_close</NAME>
<RETURNS>void </RETURNS>
InfTcpConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>inf_tcp_connection_send</NAME>
<RETURNS>void </RETURNS>
InfTcpConnection* connection,gconstpointer data,guint len
</FUNCTION>
<FUNCTION>
<NAME>inf_tcp_connection_get_remote_address</NAME>
<RETURNS>InfIpAddress *</RETURNS>
InfTcpConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>inf_tcp_connection_get_remote_port</NAME>
<RETURNS>guint </RETURNS>
InfTcpConnection* connection
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_BUFFER</NAME>
#define INF_TYPE_BUFFER                 (inf_buffer_get_type())
</MACRO>
<MACRO>
<NAME>INF_BUFFER</NAME>
#define INF_BUFFER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_BUFFER, InfBuffer))
</MACRO>
<MACRO>
<NAME>INF_IS_BUFFER</NAME>
#define INF_IS_BUFFER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_BUFFER))
</MACRO>
<MACRO>
<NAME>INF_BUFFER_GET_IFACE</NAME>
#define INF_BUFFER_GET_IFACE(inst)      (G_TYPE_INSTANCE_GET_INTERFACE((inst), INF_TYPE_BUFFER, InfBufferIface))
</MACRO>
<STRUCT>
<NAME>InfBuffer</NAME>
</STRUCT>
<STRUCT>
<NAME>InfBufferIface</NAME>
</STRUCT>
<STRUCT>
<NAME>InfBufferIface</NAME>
struct _InfBufferIface {
  GTypeInterface parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_buffer_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_METHOD_MANAGER</NAME>
#define INF_TYPE_METHOD_MANAGER                 (inf_method_manager_get_type())
</MACRO>
<MACRO>
<NAME>INF_METHOD_MANAGER</NAME>
#define INF_METHOD_MANAGER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_METHOD_MANAGER, InfMethodManager))
</MACRO>
<MACRO>
<NAME>INF_METHOD_MANAGER_CLASS</NAME>
#define INF_METHOD_MANAGER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_TYPE_METHOD_MANAGER, InfMethodManagerClass))
</MACRO>
<MACRO>
<NAME>INF_IS_METHOD_MANAGER</NAME>
#define INF_IS_METHOD_MANAGER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_METHOD_MANAGER))
</MACRO>
<MACRO>
<NAME>INF_IS_METHOD_MANAGER_CLASS</NAME>
#define INF_IS_METHOD_MANAGER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_TYPE_METHOD_MANAGER))
</MACRO>
<MACRO>
<NAME>INF_METHOD_MANAGER_GET_CLASS</NAME>
#define INF_METHOD_MANAGER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_TYPE_METHOD_MANAGER, InfMethodManagerClass))
</MACRO>
<STRUCT>
<NAME>InfMethodManager</NAME>
</STRUCT>
<STRUCT>
<NAME>InfMethodManagerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfMethodManagerClass</NAME>
struct _InfMethodManagerClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfMethodManager</NAME>
struct _InfMethodManager {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_method_manager_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_method_manager_get_default</NAME>
<RETURNS>InfMethodManager *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_method_manager_new</NAME>
<RETURNS>InfMethodManager *</RETURNS>
const gchar* search_path
</FUNCTION>
<FUNCTION>
<NAME>inf_method_manager_add_method</NAME>
<RETURNS>void </RETURNS>
InfMethodManager* manager,const InfConnectionManagerMethodDesc* method
</FUNCTION>
<FUNCTION>
<NAME>inf_method_manager_lookup_method</NAME>
<RETURNS>const InfConnectionManagerMethodDesc *</RETURNS>
InfMethodManager* manager,const gchar* network,const gchar* method_name
</FUNCTION>
<FUNCTION>
<NAME>inf_method_manager_list_methods_with_name</NAME>
<RETURNS>GSList *</RETURNS>
InfMethodManager* manager,const gchar* name
</FUNCTION>
<FUNCTION>
<NAME>inf_method_manager_list_methods_with_network</NAME>
<RETURNS>GSList *</RETURNS>
InfMethodManager* manager,const gchar* network
</FUNCTION>
<FUNCTION>
<NAME>inf_method_manager_list_all_methods</NAME>
<RETURNS>GSList *</RETURNS>
InfMethodManager* manager
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_STANDALONE_IO</NAME>
#define INF_TYPE_STANDALONE_IO                 (inf_standalone_io_get_type())
</MACRO>
<MACRO>
<NAME>INF_STANDALONE_IO</NAME>
#define INF_STANDALONE_IO(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_STANDALONE_IO, InfStandaloneIo))
</MACRO>
<MACRO>
<NAME>INF_STANDALONE_IO_CLASS</NAME>
#define INF_STANDALONE_IO_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_TYPE_STANDALONE_IO, InfStandaloneIoClass))
</MACRO>
<MACRO>
<NAME>INF_IS_STANDALONE_IO</NAME>
#define INF_IS_STANDALONE_IO(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_STANDALONE_IO))
</MACRO>
<MACRO>
<NAME>INF_IS_STANDALONE_IO_CLASS</NAME>
#define INF_IS_STANDALONE_IO_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_TYPE_STANDALONE_IO))
</MACRO>
<MACRO>
<NAME>INF_STANDALONE_IO_GET_CLASS</NAME>
#define INF_STANDALONE_IO_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_TYPE_STANDALONE_IO, InfStandaloneIoClass))
</MACRO>
<STRUCT>
<NAME>InfStandaloneIo</NAME>
</STRUCT>
<STRUCT>
<NAME>InfStandaloneIoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfStandaloneIoClass</NAME>
struct _InfStandaloneIoClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfStandaloneIo</NAME>
struct _InfStandaloneIo {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_standalone_io_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_standalone_io_new</NAME>
<RETURNS>InfStandaloneIo *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_standalone_io_iteration</NAME>
<RETURNS>void </RETURNS>
InfStandaloneIo* io
</FUNCTION>
<FUNCTION>
<NAME>inf_standalone_io_iteration_timeout</NAME>
<RETURNS>void </RETURNS>
InfStandaloneIo* io,guint timeout
</FUNCTION>
<FUNCTION>
<NAME>inf_standalone_io_loop</NAME>
<RETURNS>void </RETURNS>
InfStandaloneIo* io
</FUNCTION>
<FUNCTION>
<NAME>inf_standalone_io_loop_quit</NAME>
<RETURNS>void </RETURNS>
InfStandaloneIo* io
</FUNCTION>
<FUNCTION>
<NAME>inf_standalone_io_loop_running</NAME>
<RETURNS>gboolean </RETURNS>
InfStandaloneIo* io
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_DISCOVERY_AVAHI</NAME>
#define INF_TYPE_DISCOVERY_AVAHI                 (inf_discovery_avahi_get_type())
</MACRO>
<MACRO>
<NAME>INF_DISCOVERY_AVAHI</NAME>
#define INF_DISCOVERY_AVAHI(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_DISCOVERY_AVAHI, InfDiscoveryAvahi))
</MACRO>
<MACRO>
<NAME>INF_DISCOVERY_AVAHI_CLASS</NAME>
#define INF_DISCOVERY_AVAHI_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_TYPE_DISCOVERY_AVAHI, InfDiscoveryAvahiClass))
</MACRO>
<MACRO>
<NAME>INF_IS_DISCOVERY_AVAHI</NAME>
#define INF_IS_DISCOVERY_AVAHI(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_DISCOVERY_AVAHI))
</MACRO>
<MACRO>
<NAME>INF_IS_DISCOVERY_AVAHI_CLASS</NAME>
#define INF_IS_DISCOVERY_AVAHI_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_TYPE_DISCOVERY_AVAHI))
</MACRO>
<MACRO>
<NAME>INF_DISCOVERY_AVAHI_GET_CLASS</NAME>
#define INF_DISCOVERY_AVAHI_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_TYPE_DISCOVERY_AVAHI, InfDiscoveryAvahiClass))
</MACRO>
<STRUCT>
<NAME>InfDiscoveryAvahi</NAME>
</STRUCT>
<STRUCT>
<NAME>InfDiscoveryAvahiClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfDiscoveryAvahiClass</NAME>
struct _InfDiscoveryAvahiClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfDiscoveryAvahi</NAME>
struct _InfDiscoveryAvahi {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_discovery_avahi_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_discovery_avahi_new</NAME>
<RETURNS>InfDiscoveryAvahi *</RETURNS>
InfIo* io,InfXmppManager* manager,gnutls_certificate_credentials_t creds,Gsasl* sasl_context
</FUNCTION>
<ENUM>
<NAME>InfRequestError</NAME>
typedef enum _InfRequestError {
  /* Synchronization is still in progress. */
  INF_REQUEST_ERROR_SYNCHRONIZING,
  /* Received an unexpected message */
  INF_REQUEST_ERROR_UNEXPECTED_MESSAGE,
  /* Unknown error domain */
  INF_REQUEST_ERROR_UNKNOWN_DOMAIN,
  /* Server reply could not be processed */
  INF_REQUEST_ERROR_REPLY_UNPROCESSED,
  /* Server reply had invalid sequence number set */
  INF_REQUEST_ERROR_INVALID_SEQ,
  /* A required attribute was not set */
  INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
  /* An attribute expected to contain a number contained something else,
   * or an overflow occured */
  INF_REQUEST_ERROR_INVALID_NUMBER,

  INF_REQUEST_ERROR_FAILED
} InfRequestError;
</ENUM>
<ENUM>
<NAME>InfUserJoinError</NAME>
typedef enum _InfUserJoinError {
  /* The requested name is already in use by another user */
  INF_USER_JOIN_ERROR_NAME_IN_USE,
  /* An id attribute was provided, but the server assigns it */
  INF_USER_JOIN_ERROR_ID_PROVIDED,
  /* User is not present, in case of a user rejoin */
  INF_USER_JOIN_ERROR_NO_SUCH_USER,
  /* A status attribute was provided, but the status is always
   * 'available' after a user-join. */
  INF_USER_JOIN_ERROR_STATUS_PROVIDED,

  INF_USER_JOIN_ERROR_FAILED
} InfUserJoinError;
</ENUM>
<ENUM>
<NAME>InfUserStatusChangeError</NAME>
typedef enum _InfUserStatusChangeError {
  /* There is no user with the given ID */
  INF_USER_STATUS_CHANGE_ERROR_NO_SUCH_USER,
  /* The user did not join from the connection the request comes from */
  INF_USER_STATUS_CHANGE_ERROR_NOT_JOINED,
  /* An invalid status was given */
  INF_USER_STATUS_CHANGE_ERROR_INVALID_STATUS,

  INF_USER_STATUS_CHANGE_ERROR_FAILED
} InfUserStatusChangeError;
</ENUM>
<ENUM>
<NAME>InfDirectoryError</NAME>
typedef enum _InfDirectoryError {
  /* A node with this name exists already */
  INF_DIRECTORY_ERROR_NODE_EXISTS,
  /* The node referred to does not exist */
  INF_DIRECTORY_ERROR_NO_SUCH_NODE,
  /* The node referred to is not a subdirectory */
  INF_DIRECTORY_ERROR_NOT_A_SUBDIRECTORY,
  /* The node referred to is not a note */
  INF_DIRECTORY_ERROR_NOT_A_NOTE,
  /* TODO: Make an own error domain out of the explore errors */
  /* The given subdirectory has already been explored */
  INF_DIRECTORY_ERROR_ALREADY_EXPLORED,
  /* There is no plugin that covers the given type */
  INF_DIRECTORY_ERROR_TYPE_UNKNOWN,
  /* The server sends more explored children that previously announced */
  INF_DIRECTORY_ERROR_TOO_MUCH_CHILDREN,
  /* The server sent explore-end before having sent all children */
  INF_DIRECTORY_ERROR_TOO_FEW_CHILDREN,
  /* The connection is already subscribed to the session */
  INF_DIRECTORY_ERROR_ALREADY_SUBSCRIBED,
  /* The connection is not subscribed to the session */
  INF_DIRECTORY_ERROR_UNSUBSCRIBED,
  /* Session does not support the network of the requesting connection */
  INF_DIRECTORY_ERROR_NETWORK_UNSUPPORTED,
  /* Session uses unsupported communication method */
  INF_DIRECTORY_ERROR_METHOD_UNSUPPORTED,
  /* Got unexpected XML message */
  INF_DIRECTORY_ERROR_UNEXPECTED_MESSAGE,

  INF_DIRECTORY_ERROR_FAILED
} InfDirectoryError;
</ENUM>
<FUNCTION>
<NAME>inf_request_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_request_strerror</NAME>
<RETURNS>const gchar *</RETURNS>
InfRequestError code
</FUNCTION>
<FUNCTION>
<NAME>inf_user_join_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_user_join_strerror</NAME>
<RETURNS>const gchar *</RETURNS>
InfUserJoinError code
</FUNCTION>
<FUNCTION>
<NAME>inf_user_status_change_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_user_status_change_strerror</NAME>
<RETURNS>const gchar *</RETURNS>
InfUserStatusChangeError code
</FUNCTION>
<FUNCTION>
<NAME>inf_directory_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_directory_strerror</NAME>
<RETURNS>const gchar *</RETURNS>
InfDirectoryError code
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_USER</NAME>
#define INF_TYPE_USER                 (inf_user_get_type())
</MACRO>
<MACRO>
<NAME>INF_USER</NAME>
#define INF_USER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_USER, InfUser))
</MACRO>
<MACRO>
<NAME>INF_USER_CLASS</NAME>
#define INF_USER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_TYPE_USER, InfUserClass))
</MACRO>
<MACRO>
<NAME>INF_IS_USER</NAME>
#define INF_IS_USER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_USER))
</MACRO>
<MACRO>
<NAME>INF_IS_USER_CLASS</NAME>
#define INF_IS_USER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_TYPE_USER))
</MACRO>
<MACRO>
<NAME>INF_USER_GET_CLASS</NAME>
#define INF_USER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_TYPE_USER, InfUserClass))
</MACRO>
<MACRO>
<NAME>INF_TYPE_USER_STATUS</NAME>
#define INF_TYPE_USER_STATUS          (inf_user_status_get_type())
</MACRO>
<MACRO>
<NAME>INF_TYPE_USER_FLAGS</NAME>
#define INF_TYPE_USER_FLAGS           (inf_user_flags_get_type())
</MACRO>
<STRUCT>
<NAME>InfUser</NAME>
</STRUCT>
<STRUCT>
<NAME>InfUserClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfUserClass</NAME>
struct _InfUserClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfUser</NAME>
struct _InfUser {
  GObject parent;
};

</STRUCT>
<ENUM>
<NAME>InfUserStatus</NAME>
typedef enum _InfUserStatus {
  INF_USER_AVAILABLE,
  INF_USER_UNAVAILABLE
  /* TODO: Add further status (AWAY, ...) */
} InfUserStatus;
</ENUM>
<ENUM>
<NAME>InfUserFlags</NAME>
typedef enum InfUserFlags {
  INF_USER_LOCAL = 1 << 0
} InfUserFlags;
</ENUM>
<FUNCTION>
<NAME>inf_user_status_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_user_flags_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_user_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_user_get_id</NAME>
<RETURNS>guint </RETURNS>
const InfUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_user_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
const InfUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_user_get_status</NAME>
<RETURNS>InfUserStatus </RETURNS>
const InfUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_user_get_flags</NAME>
<RETURNS>InfUserFlags </RETURNS>
const InfUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_user_get_connection</NAME>
<RETURNS>InfXmlConnection *</RETURNS>
InfUser* user
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_DISCOVERY</NAME>
#define INF_TYPE_DISCOVERY                 (inf_discovery_get_type())
</MACRO>
<MACRO>
<NAME>INF_DISCOVERY</NAME>
#define INF_DISCOVERY(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_DISCOVERY, InfDiscovery))
</MACRO>
<MACRO>
<NAME>INF_IS_DISCOVERY</NAME>
#define INF_IS_DISCOVERY(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_DISCOVERY))
</MACRO>
<MACRO>
<NAME>INF_DISCOVERY_GET_IFACE</NAME>
#define INF_DISCOVERY_GET_IFACE(inst)      (G_TYPE_INSTANCE_GET_INTERFACE((inst), INF_TYPE_DISCOVERY, InfDiscoveryIface))
</MACRO>
<STRUCT>
<NAME>InfDiscovery</NAME>
</STRUCT>
<STRUCT>
<NAME>InfDiscoveryIface</NAME>
</STRUCT>
<STRUCT>
<NAME>InfDiscoveryInfo</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>InfDiscoveryResolvCompleteFunc</NAME>
<RETURNS>void </RETURNS>
InfDiscoveryInfo* info,
                                              InfXmlConnection* connection,
                                              gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>InfDiscoveryResolvErrorFunc</NAME>
<RETURNS>void </RETURNS>
InfDiscoveryInfo* info,
                                           const GError* error,
                                           gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>InfDiscoveryIface</NAME>
struct _InfDiscoveryIface {
  GTypeInterface parent;

  void (*discover)(InfDiscovery* discovery,
                   const gchar* type);

  GSList* (*get_discovered)(InfDiscovery* discovery,
                            const gchar* type);

  void (*resolve)(InfDiscovery* discovery,
                  InfDiscoveryInfo* info,
                  InfDiscoveryResolvCompleteFunc complete_func,
                  InfDiscoveryResolvErrorFunc error_func,
                  gpointer user_data);

  gchar*(*info_get_service_name)(InfDiscovery* discovery,
                                 InfDiscoveryInfo* info);

  const gchar*(*info_get_service_type)(InfDiscovery* discovery,
                                       InfDiscoveryInfo* info);

  /* Signals */
  void (*discovered)(InfDiscovery* discovery,
                     InfDiscoveryInfo* info);

  void (*undiscovered)(InfDiscovery* discovry,
                       InfDiscoveryInfo* info);
};

</STRUCT>
<FUNCTION>
<NAME>inf_discovery_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_discovery_discover</NAME>
<RETURNS>void </RETURNS>
InfDiscovery* discovery,const gchar* type
</FUNCTION>
<FUNCTION>
<NAME>inf_discovery_get_discovered</NAME>
<RETURNS>GSList *</RETURNS>
InfDiscovery* discovery,const gchar* type
</FUNCTION>
<FUNCTION>
<NAME>inf_discovery_resolve</NAME>
<RETURNS>void </RETURNS>
InfDiscovery* discovery,InfDiscoveryInfo* info,InfDiscoveryResolvCompleteFunc complete_func,InfDiscoveryResolvErrorFunc error_func,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>inf_discovery_info_get_service_name</NAME>
<RETURNS>gchar *</RETURNS>
InfDiscovery* discovery,InfDiscoveryInfo* info
</FUNCTION>
<FUNCTION>
<NAME>inf_discovery_info_get_service_type</NAME>
<RETURNS>const gchar *</RETURNS>
InfDiscovery* discovery,InfDiscoveryInfo* info
</FUNCTION>
<FUNCTION>
<NAME>inf_discovery_discovered</NAME>
<RETURNS>void </RETURNS>
InfDiscovery* discovery,InfDiscoveryInfo* info
</FUNCTION>
<FUNCTION>
<NAME>inf_discovery_undiscovered</NAME>
<RETURNS>void </RETURNS>
InfDiscovery* discovery,InfDiscoveryInfo* info
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_USER_TABLE</NAME>
#define INF_TYPE_USER_TABLE                 (inf_user_table_get_type())
</MACRO>
<MACRO>
<NAME>INF_USER_TABLE</NAME>
#define INF_USER_TABLE(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_USER_TABLE, InfUserTable))
</MACRO>
<MACRO>
<NAME>INF_USER_TABLE_CLASS</NAME>
#define INF_USER_TABLE_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_TYPE_USER_TABLE, InfUserTableClass))
</MACRO>
<MACRO>
<NAME>INF_IS_USER_TABLE</NAME>
#define INF_IS_USER_TABLE(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_USER_TABLE))
</MACRO>
<MACRO>
<NAME>INF_IS_USER_TABLE_CLASS</NAME>
#define INF_IS_USER_TABLE_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_TYPE_USER_TABLE))
</MACRO>
<MACRO>
<NAME>INF_USER_TABLE_GET_CLASS</NAME>
#define INF_USER_TABLE_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_TYPE_USER_TABLE, InfUserTableClass))
</MACRO>
<STRUCT>
<NAME>InfUserTable</NAME>
</STRUCT>
<STRUCT>
<NAME>InfUserTableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfUserTableClass</NAME>
struct _InfUserTableClass {
  GObjectClass parent_class;

  /* Signals */
  void(*add_user)(InfUserTable* user_table,
                  InfUser* user);

  void(*remove_user)(InfUserTable* user_table,
                     InfUser* user);

  void(*add_local_user)(InfUserTable* user_table,
                        InfUser* user);

  void(*remove_local_user)(InfUserTable* user_tabel,
                           InfUser* user);
};

</STRUCT>
<STRUCT>
<NAME>InfUserTable</NAME>
struct _InfUserTable {
  GObject parent;
};

</STRUCT>
<USER_FUNCTION>
<NAME>InfUserTableForeachUserFunc</NAME>
<RETURNS>void </RETURNS>
InfUser*, gpointer
</USER_FUNCTION>
<FUNCTION>
<NAME>inf_user_table_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_user_table_new</NAME>
<RETURNS>InfUserTable *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_user_table_add_user</NAME>
<RETURNS>void </RETURNS>
InfUserTable* user_table,InfUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_user_table_remove_user</NAME>
<RETURNS>void </RETURNS>
InfUserTable* user_table,InfUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_user_table_lookup_user_by_id</NAME>
<RETURNS>InfUser *</RETURNS>
InfUserTable* user_table,guint id
</FUNCTION>
<FUNCTION>
<NAME>inf_user_table_lookup_user_by_name</NAME>
<RETURNS>InfUser *</RETURNS>
InfUserTable* user_table,const gchar* name
</FUNCTION>
<FUNCTION>
<NAME>inf_user_table_foreach_user</NAME>
<RETURNS>void </RETURNS>
InfUserTable* user_table,InfUserTableForeachUserFunc func,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>inf_user_table_foreach_local_user</NAME>
<RETURNS>void </RETURNS>
InfUserTable* user_table,InfUserTableForeachUserFunc func,gpointer user_data
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_NET_OBJECT</NAME>
#define INF_TYPE_NET_OBJECT                 (inf_net_object_get_type())
</MACRO>
<MACRO>
<NAME>INF_NET_OBJECT</NAME>
#define INF_NET_OBJECT(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_NET_OBJECT, InfNetObject))
</MACRO>
<MACRO>
<NAME>INF_IS_NET_OBJECT</NAME>
#define INF_IS_NET_OBJECT(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_NET_OBJECT))
</MACRO>
<MACRO>
<NAME>INF_NET_OBJECT_GET_IFACE</NAME>
#define INF_NET_OBJECT_GET_IFACE(inst)      (G_TYPE_INSTANCE_GET_INTERFACE((inst), INF_TYPE_NET_OBJECT, InfNetObjectIface))
</MACRO>
<STRUCT>
<NAME>InfNetObject</NAME>
</STRUCT>
<STRUCT>
<NAME>InfNetObjectIface</NAME>
</STRUCT>
<STRUCT>
<NAME>InfNetObjectIface</NAME>
struct _InfNetObjectIface {
  GTypeInterface parent;

  /* Virtual Table */
  gboolean (*received)(InfNetObject* object,
                       InfXmlConnection* conn,
                       xmlNodePtr node,
                       GError** error);

  void (*enqueued)(InfNetObject* object,
                   InfXmlConnection* conn,
                   xmlNodePtr node);

  void (*sent)(InfNetObject* object,
               InfXmlConnection* conn,
               xmlNodePtr node);
};

</STRUCT>
<FUNCTION>
<NAME>inf_net_object_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_net_object_received</NAME>
<RETURNS>gboolean </RETURNS>
InfNetObject* object,InfXmlConnection* conn,xmlNodePtr node,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_net_object_enqueued</NAME>
<RETURNS>void </RETURNS>
InfNetObject* object,InfXmlConnection* conn,xmlNodePtr node
</FUNCTION>
<FUNCTION>
<NAME>inf_net_object_sent</NAME>
<RETURNS>void </RETURNS>
InfNetObject* object,InfXmlConnection* conn,xmlNodePtr node
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_IO</NAME>
#define INF_TYPE_IO                 (inf_io_get_type())
</MACRO>
<MACRO>
<NAME>INF_IO</NAME>
#define INF_IO(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_IO, InfIo))
</MACRO>
<MACRO>
<NAME>INF_IS_IO</NAME>
#define INF_IS_IO(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_IO))
</MACRO>
<MACRO>
<NAME>INF_IO_GET_IFACE</NAME>
#define INF_IO_GET_IFACE(inst)      (G_TYPE_INSTANCE_GET_INTERFACE((inst), INF_TYPE_IO, InfIoIface))
</MACRO>
<MACRO>
<NAME>INF_TYPE_IO_EVENT</NAME>
#define INF_TYPE_IO_EVENT           (inf_io_event_get_type())
</MACRO>
<STRUCT>
<NAME>InfIo</NAME>
</STRUCT>
<STRUCT>
<NAME>InfIoIface</NAME>
</STRUCT>
<TYPEDEF>
<NAME>InfNativeSocket</NAME>
typedef int InfNativeSocket;
</TYPEDEF>
<ENUM>
<NAME>InfIoEvent</NAME>
typedef enum _InfIoEvent {
  INF_IO_INCOMING = 1 << 0,
  INF_IO_OUTGOING = 1 << 1,
  INF_IO_ERROR    = 1 << 2
} InfIoEvent;
</ENUM>
<USER_FUNCTION>
<NAME>InfIoFunc</NAME>
<RETURNS>void </RETURNS>
InfNativeSocket* socket,
                         InfIoEvent event,
                         gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>InfIoTimeoutFunc</NAME>
<RETURNS>void </RETURNS>
gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>InfIoIface</NAME>
struct _InfIoIface {
  GTypeInterface parent;

  /* Virtual table */
  void (*watch)(InfIo* io,
                InfNativeSocket* socket,
                InfIoEvent events,
                InfIoFunc func,
                gpointer user_data,
                GDestroyNotify notify);

  gpointer (*add_timeout)(InfIo* io,
                          guint msecs,
                          InfIoTimeoutFunc func,
                          gpointer user_data,
                          GDestroyNotify notify);

  void (*remove_timeout)(InfIo* io,
                         gpointer timeout);
};

</STRUCT>
<FUNCTION>
<NAME>inf_io_event_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_io_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_io_watch</NAME>
<RETURNS>void </RETURNS>
InfIo* io,InfNativeSocket* socket,InfIoEvent events,InfIoFunc func,gpointer user_data,GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>inf_io_add_timeout</NAME>
<RETURNS>gpointer </RETURNS>
InfIo* io,guint msecs,InfIoTimeoutFunc func,gpointer user_data,GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>inf_io_remove_timeout</NAME>
<RETURNS>void </RETURNS>
InfIo* io,gpointer timeout
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_SESSION</NAME>
#define INF_TYPE_SESSION                 (inf_session_get_type())
</MACRO>
<MACRO>
<NAME>INF_SESSION</NAME>
#define INF_SESSION(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_SESSION, InfSession))
</MACRO>
<MACRO>
<NAME>INF_SESSION_CLASS</NAME>
#define INF_SESSION_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_TYPE_SESSION, InfSessionClass))
</MACRO>
<MACRO>
<NAME>INF_IS_SESSION</NAME>
#define INF_IS_SESSION(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_SESSION))
</MACRO>
<MACRO>
<NAME>INF_IS_SESSION_CLASS</NAME>
#define INF_IS_SESSION_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_TYPE_SESSION))
</MACRO>
<MACRO>
<NAME>INF_SESSION_GET_CLASS</NAME>
#define INF_SESSION_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_TYPE_SESSION, InfSessionClass))
</MACRO>
<MACRO>
<NAME>INF_TYPE_SESSION_STATUS</NAME>
#define INF_TYPE_SESSION_STATUS          (inf_session_status_get_type())
</MACRO>
<STRUCT>
<NAME>InfSession</NAME>
</STRUCT>
<STRUCT>
<NAME>InfSessionClass</NAME>
</STRUCT>
<ENUM>
<NAME>InfSessionStatus</NAME>
typedef enum _InfSessionStatus {
  INF_SESSION_SYNCHRONIZING,
  INF_SESSION_RUNNING,
  INF_SESSION_CLOSED
} InfSessionStatus;
</ENUM>
<ENUM>
<NAME>InfSessionSyncStatus</NAME>
typedef enum _InfSessionSyncStatus {
  /* No synchronization in progress */
  INF_SESSION_SYNC_NONE,
  /* The synchronization is in progress */
  INF_SESSION_SYNC_IN_PROGRESS,
  /* The synchronization is in progress and cannot be cancelled anymore. */
  /*INF_SESSION_SYNC_END_ENQUEUED*/
  /* The synchronization is finished, we are only waiting for the
   * acknowledgment from the remote site. */
  INF_SESSION_SYNC_AWAITING_ACK
} InfSessionSyncStatus;
</ENUM>
<ENUM>
<NAME>InfSessionSyncError</NAME>
typedef enum _InfSessionSyncError {
  /* Got unexpected XML node during synchronization */
  INF_SESSION_SYNC_ERROR_UNEXPECTED_NODE,
  /* id attribute not present in XML node */
  INF_SESSION_SYNC_ERROR_ID_NOT_PRESENT,
  /* The ID is already in use by another user */
  INF_SESSION_SYNC_ERROR_ID_IN_USE,
  /* name attribute not present in XML node */
  INF_SESSION_SYNC_ERROR_NAME_NOT_PRESENT,
  /* The name is already in use by another user */
  INF_SESSION_SYNC_ERROR_NAME_IN_USE,
  /* The underlaying connection has been closed */
  INF_SESSION_SYNC_ERROR_CONNECTION_CLOSED,
  /* The sender has cancelled the synchronization */
  INF_SESSION_SYNC_ERROR_SENDER_CANCELLED,
  /* The receiver has cancelled the synchronization */
  INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED,
  /* Got begin-of-sync message, but sync is already in progress */
  INF_SESSION_SYNC_ERROR_UNEXPECTED_BEGIN_OF_SYNC,
  /* The begin-of-sync message does not contain the number of messages
   * to expect */
  INF_SESSION_SYNC_ERROR_NUM_MESSAGES_MISSING,
  /* Got end-of-sync, but sync is still in progress */
  INF_SESSION_SYNC_ERROR_UNEXPECTED_END_OF_SYNC,
  /* Sync has just started, but first message was not begin-of-sync */
  INF_SESSION_SYNC_ERROR_EXPECTED_BEGIN_OF_SYNC,
  /* Last sync message shoud be end-of-sync, but it is not */
  INF_SESSION_SYNC_ERROR_EXPECTED_END_OF_SYNC,

  INF_SESSION_SYNC_ERROR_FAILED
} InfSessionSyncError;
</ENUM>
<STRUCT>
<NAME>InfSessionClass</NAME>
struct _InfSessionClass {
  GObjectClass parent_class;

  /* Virtual table */

  /* This should save the session within a XML document. parent is the root
   * node of the document. It should create as much nodes as possible within
   * that root node and not in sub-nodes because these are sent to the client
   * and it is allowed that other traffic is put inbetween those notes. This
   * way, communication through the same connection does not hang just because
   * a large document is synchronized. */
  void(*to_xml_sync)(InfSession* session,
                     xmlNodePtr parent);

  /* This method is called for every node in the XML document created above
   * on the other site. It should reconstruct the session. */
  gboolean(*process_xml_sync)(InfSession* session,
                              InfXmlConnection* connection,
                              const xmlNodePtr xml,
                              GError** error);

  /* This method is called for every received message while the session is
   * running. Return TRUE if forward is allowed. */
  gboolean(*process_xml_run)(InfSession* session,
                             InfXmlConnection* connection,
                             const xmlNodePtr xml,
                             GError** error);

  /* Creates a list of parameters from an XML node. */
  GArray*(*get_xml_user_props)(InfSession* session,
                               InfXmlConnection* conn,
                               const xmlNodePtr xml);

  /* This turns a list of parameters (user properties) back into an XML node
   * to be sent through the network. */
  void (*set_xml_user_props)(InfSession* session,
                             const GParameter* params,
                             guint n_params,
                             xmlNodePtr xml);

  gboolean(*validate_user_props)(InfSession* session,
                                 const GParameter* params,
                                 guint n_params,
                                 InfUser* exclude,
                                 GError** error);

  InfUser*(*user_new)(InfSession* session,
                      const GParameter* params,
                      guint n_params);

  /* Signals */
  void(*close)(InfSession* session);

  void(*synchronization_begin)(InfSession* session,
                               InfConnectionManagerGroup* group,
                               InfXmlConnection* connection);

  void(*synchronization_progress)(InfSession* session,
                                  InfXmlConnection* connection,
                                  gdouble percentage);

  void(*synchronization_complete)(InfSession* session,
                                  InfXmlConnection* connection);

  void(*synchronization_failed)(InfSession* session,
                                InfXmlConnection* connection,
                                const GError* error);
};

</STRUCT>
<STRUCT>
<NAME>InfSession</NAME>
struct _InfSession {
  GObject parent;
};

</STRUCT>
<USER_FUNCTION>
<NAME>InfSessionForeachUserFunc</NAME>
<RETURNS>void </RETURNS>
InfUser* user,
                                         gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>inf_session_lookup_user_property</NAME>
<RETURNS>const GParameter *</RETURNS>
const GParameter* params,guint n_params,const gchar* name
</FUNCTION>
<FUNCTION>
<NAME>inf_session_get_user_property</NAME>
<RETURNS>GParameter *</RETURNS>
GArray* array,const gchar* name
</FUNCTION>
<FUNCTION>
<NAME>inf_session_status_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_session_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_session_user_to_xml</NAME>
<RETURNS>void </RETURNS>
InfSession* session,InfUser* user,xmlNodePtr xml
</FUNCTION>
<FUNCTION>
<NAME>inf_session_close</NAME>
<RETURNS>void </RETURNS>
InfSession* session
</FUNCTION>
<FUNCTION>
<NAME>inf_session_get_connection_manager</NAME>
<RETURNS>InfConnectionManager *</RETURNS>
InfSession* session
</FUNCTION>
<FUNCTION>
<NAME>inf_session_get_buffer</NAME>
<RETURNS>InfBuffer *</RETURNS>
InfSession* session
</FUNCTION>
<FUNCTION>
<NAME>inf_session_get_user_table</NAME>
<RETURNS>InfUserTable *</RETURNS>
InfSession* session
</FUNCTION>
<FUNCTION>
<NAME>inf_session_get_status</NAME>
<RETURNS>InfSessionStatus </RETURNS>
InfSession* session
</FUNCTION>
<FUNCTION>
<NAME>inf_session_add_user</NAME>
<RETURNS>InfUser *</RETURNS>
InfSession* session,const GParameter* params,guint n_params,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_session_synchronize_to</NAME>
<RETURNS>void </RETURNS>
InfSession* session,InfConnectionManagerGroup* group,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>inf_session_get_synchronization_status</NAME>
<RETURNS>InfSessionSyncStatus </RETURNS>
InfSession* session,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>inf_session_get_synchronization_progress</NAME>
<RETURNS>gdouble </RETURNS>
InfSession* session,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>inf_session_has_synchronizations</NAME>
<RETURNS>gboolean </RETURNS>
InfSession* session
</FUNCTION>
<FUNCTION>
<NAME>inf_session_get_subscription_group</NAME>
<RETURNS>InfConnectionManagerGroup *</RETURNS>
InfSession* session
</FUNCTION>
<FUNCTION>
<NAME>inf_session_set_subscription_group</NAME>
<RETURNS>void </RETURNS>
InfSession* session,InfConnectionManagerGroup* group
</FUNCTION>
<FUNCTION>
<NAME>inf_session_send_to_subscriptions</NAME>
<RETURNS>void </RETURNS>
InfSession* session,InfXmlConnection* except,xmlNodePtr xml
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_IP_ADDRESS</NAME>
#define INF_TYPE_IP_ADDRESS                 (inf_ip_address_get_type())
</MACRO>
<MACRO>
<NAME>INF_TYPE_IP_ADDRESS_FAMILY</NAME>
#define INF_TYPE_IP_ADDRESS_FAMILY          (inf_ip_address_family_get_type())
</MACRO>
<STRUCT>
<NAME>InfIpAddress</NAME>
</STRUCT>
<ENUM>
<NAME>InfIpAddressFamily</NAME>
typedef enum _InfIpAddressFamily {
  INF_IP_ADDRESS_IPV4,
  INF_IP_ADDRESS_IPV6
} InfIpAddressFamily;
</ENUM>
<FUNCTION>
<NAME>inf_ip_address_family_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_new_raw4</NAME>
<RETURNS>InfIpAddress *</RETURNS>
guint32 address
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_new_loopback4</NAME>
<RETURNS>InfIpAddress *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_new_raw6</NAME>
<RETURNS>InfIpAddress *</RETURNS>
const guint8 address[16]
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_new_loopback6</NAME>
<RETURNS>InfIpAddress *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_new_from_string</NAME>
<RETURNS>InfIpAddress *</RETURNS>
const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_copy</NAME>
<RETURNS>InfIpAddress *</RETURNS>
const InfIpAddress* address
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_free</NAME>
<RETURNS>void </RETURNS>
InfIpAddress* address
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_get_family</NAME>
<RETURNS>InfIpAddressFamily </RETURNS>
const InfIpAddress* address
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_get_raw</NAME>
<RETURNS>gconstpointer </RETURNS>
const InfIpAddress* address
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_to_string</NAME>
<RETURNS>gchar *</RETURNS>
const InfIpAddress* address
</FUNCTION>
<FUNCTION>
<NAME>inf_ip_address_collate</NAME>
<RETURNS>int </RETURNS>
const InfIpAddress* address1,const InfIpAddress* address2
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_get_attribute</NAME>
<RETURNS>xmlChar *</RETURNS>
xmlNodePtr xml,const gchar* attribute
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_get_attribute_required</NAME>
<RETURNS>xmlChar *</RETURNS>
xmlNodePtr xml,const gchar* attribute,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_get_attribute_int</NAME>
<RETURNS>gboolean </RETURNS>
xmlNodePtr xml,const gchar* attribute,gint* result,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_get_attribute_int_required</NAME>
<RETURNS>gboolean </RETURNS>
xmlNodePtr xml,const gchar* attribute,gint* result,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_get_attribute_uint</NAME>
<RETURNS>gboolean </RETURNS>
xmlNodePtr xml,const gchar* attribute,guint* result,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_get_attribute_uint_required</NAME>
<RETURNS>gboolean </RETURNS>
xmlNodePtr xml,const gchar* attribute,guint* result,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_get_attribute_double</NAME>
<RETURNS>gboolean </RETURNS>
xmlNodePtr xml,const gchar* attribute,gdouble* result,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_get_attribute_double_required</NAME>
<RETURNS>gboolean </RETURNS>
xmlNodePtr xml,const gchar* attribute,gdouble* result,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_set_attribute</NAME>
<RETURNS>void </RETURNS>
xmlNodePtr xml,const gchar* attribute,const gchar* value
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_set_attribute_int</NAME>
<RETURNS>void </RETURNS>
xmlNodePtr xml,const gchar* attribute,gint value
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_set_attribute_uint</NAME>
<RETURNS>void </RETURNS>
xmlNodePtr xml,const gchar* attribute,guint value
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_util_set_attribute_double</NAME>
<RETURNS>void </RETURNS>
xmlNodePtr xml,const gchar* attribute,gdouble value
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_XMPP_MANAGER</NAME>
#define INF_TYPE_XMPP_MANAGER                 (inf_xmpp_manager_get_type())
</MACRO>
<MACRO>
<NAME>INF_XMPP_MANAGER</NAME>
#define INF_XMPP_MANAGER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_XMPP_MANAGER, InfXmppManager))
</MACRO>
<MACRO>
<NAME>INF_XMPP_MANAGER_CLASS</NAME>
#define INF_XMPP_MANAGER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_TYPE_XMPP_MANAGER, InfXmppManagerClass))
</MACRO>
<MACRO>
<NAME>INF_IS_XMPP_MANAGER</NAME>
#define INF_IS_XMPP_MANAGER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_XMPP_MANAGER))
</MACRO>
<MACRO>
<NAME>INF_IS_XMPP_MANAGER_CLASS</NAME>
#define INF_IS_XMPP_MANAGER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_TYPE_XMPP_MANAGER))
</MACRO>
<MACRO>
<NAME>INF_XMPP_MANAGER_GET_CLASS</NAME>
#define INF_XMPP_MANAGER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_TYPE_XMPP_MANAGER, InfXmppManagerClass))
</MACRO>
<STRUCT>
<NAME>InfXmppManager</NAME>
</STRUCT>
<STRUCT>
<NAME>InfXmppManagerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfXmppManagerClass</NAME>
struct _InfXmppManagerClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfXmppManager</NAME>
struct _InfXmppManager {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_xmpp_manager_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_xmpp_manager_new</NAME>
<RETURNS>InfXmppManager *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_xmpp_manager_lookup_connection_by_address</NAME>
<RETURNS>InfXmppConnection *</RETURNS>
InfXmppManager* manager,InfIpAddress* address,guint port
</FUNCTION>
<FUNCTION>
<NAME>inf_xmpp_manager_contains_connection</NAME>
<RETURNS>gboolean </RETURNS>
InfXmppManager* manager,InfXmppConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>inf_xmpp_manager_add_connection</NAME>
<RETURNS>void </RETURNS>
InfXmppManager* manager,InfXmppConnection* connection
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_XMPP_CONNECTION</NAME>
#define INF_TYPE_XMPP_CONNECTION                 (inf_xmpp_connection_get_type())
</MACRO>
<MACRO>
<NAME>INF_XMPP_CONNECTION</NAME>
#define INF_XMPP_CONNECTION(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_XMPP_CONNECTION, InfXmppConnection))
</MACRO>
<MACRO>
<NAME>INF_XMPP_CONNECTION_CLASS</NAME>
#define INF_XMPP_CONNECTION_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_TYPE_XMPP_CONNECTION, InfXmppConnectionClass))
</MACRO>
<MACRO>
<NAME>INF_IS_XMPP_CONNECTION</NAME>
#define INF_IS_XMPP_CONNECTION(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_XMPP_CONNECTION))
</MACRO>
<MACRO>
<NAME>INF_IS_XMPP_CONNECTION_CLASS</NAME>
#define INF_IS_XMPP_CONNECTION_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_TYPE_XMPP_CONNECTION))
</MACRO>
<MACRO>
<NAME>INF_XMPP_CONNECTION_GET_CLASS</NAME>
#define INF_XMPP_CONNECTION_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_TYPE_XMPP_CONNECTION, InfXmppConnectionClass))
</MACRO>
<MACRO>
<NAME>INF_TYPE_XMPP_CONNECTION_SITE</NAME>
#define INF_TYPE_XMPP_CONNECTION_SITE            (inf_xmpp_connection_site_get_type())
</MACRO>
<STRUCT>
<NAME>InfXmppConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>InfXmppConnectionClass</NAME>
</STRUCT>
<ENUM>
<NAME>InfXmppConnectionSite</NAME>
typedef enum _InfXmppConnectionSite {
  INF_XMPP_CONNECTION_SERVER,
  INF_XMPP_CONNECTION_CLIENT
} InfXmppConnectionSite;
</ENUM>
<ENUM>
<NAME>InfXmppConnectionError</NAME>
typedef enum _InfXmppConnectionError {
  /* Server does not support TLS */
  INF_XMPP_CONNECTION_ERROR_TLS_UNSUPPORTED,
  /* Got <failure> as response to <starttls> */
  INF_XMPP_CONNECTION_ERROR_TLS_FAILURE,
  /* Server does not provide authentication mechanisms */
  INF_XMPP_CONNECTION_ERROR_AUTHENTICATION_UNSUPPORTED,
  /* Server does not offer a suitable machnism */
  INF_XMPP_CONNECTION_ERROR_NO_SUITABLE_MECHANISM,

  INF_XMPP_CONNECTION_ERROR_FAILED
} InfXmppConnectionError;
</ENUM>
<ENUM>
<NAME>InfXmppConnectionStreamError</NAME>
typedef enum _InfXmppConnectionStreamError {
  INF_XMPP_CONNECTION_STREAM_ERROR_BAD_FORMAT,
  INF_XMPP_CONNECTION_STREAM_ERROR_BAD_NAMESPACE_PREFIX,
  INF_XMPP_CONNECTION_STREAM_ERROR_CONFLICT,
  INF_XMPP_CONNECTION_STREAM_ERROR_CONNECTION_TIMEOUT,
  INF_XMPP_CONNECTION_STREAM_ERROR_HOST_GONE,
  INF_XMPP_CONNECTION_STREAM_ERROR_HOST_UNKNOWN,
  INF_XMPP_CONNECTION_STREAM_ERROR_IMPROPER_ADDRESSING,
  INF_XMPP_CONNECTION_STREAM_ERROR_INTERNAL_SERVER_ERROR,
  INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_FROM,
  INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_ID,
  INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_NAMESPACE,
  INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_XML,
  INF_XMPP_CONNECTION_STREAM_ERROR_NOT_AUTHORIZED,
  INF_XMPP_CONNECTION_STREAM_ERROR_POLICY_VIOLATION,
  INF_XMPP_CONNECTION_STREAM_ERROR_REMOTE_CONNECTION_FAILED,
  INF_XMPP_CONNECTION_STREAM_ERROR_RESOURCE_CONSTRAINT,
  INF_XMPP_CONNECTION_STREAM_ERROR_RESTRICTED_XML,
  INF_XMPP_CONNECTION_STREAM_ERROR_SEE_OTHER_HOST,
  INF_XMPP_CONNECTION_STREAM_ERROR_SYSTEM_SHUTDOWN,
  INF_XMPP_CONNECTION_STREAM_ERROR_UNDEFINED_CONDITION,
  INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_ENCODING,
  INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_STANZA_TYPE,
  INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_VERSION,
  INF_XMPP_CONNECTION_STREAM_ERROR_XML_NOT_WELL_FORMED,

  INF_XMPP_CONNECTION_STREAM_ERROR_FAILED
} InfXmppConnectionStreamError;
</ENUM>
<ENUM>
<NAME>InfXmppConnectionAuthError</NAME>
typedef enum _InfXmppConnectionAuthError {
  INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED,
  INF_XMPP_CONNECTION_AUTH_ERROR_INCORRECT_ENCODING,
  INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_AUTHZID,
  INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM,
  INF_XMPP_CONNECTION_AUTH_ERROR_MECHANISM_TOO_WEAK,
  INF_XMPP_CONNECTION_AUTH_ERROR_NOT_AUTHORIZED,
  INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE,

  INF_XMPP_CONNECTION_AUTH_ERROR_FAILED
} InfXmppConnectionAuthError;
</ENUM>
<STRUCT>
<NAME>InfXmppConnectionClass</NAME>
struct _InfXmppConnectionClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfXmppConnection</NAME>
struct _InfXmppConnection {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_xmpp_connection_site_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_xmpp_connection_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_xmpp_connection_new</NAME>
<RETURNS>InfXmppConnection *</RETURNS>
InfTcpConnection* tcp,InfXmppConnectionSite site,const gchar* jid,gnutls_certificate_credentials_t cred,Gsasl* sasl_context
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_XML_CONNECTION</NAME>
#define INF_TYPE_XML_CONNECTION                 (inf_xml_connection_get_type())
</MACRO>
<MACRO>
<NAME>INF_XML_CONNECTION</NAME>
#define INF_XML_CONNECTION(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_XML_CONNECTION, InfXmlConnection))
</MACRO>
<MACRO>
<NAME>INF_IS_XML_CONNECTION</NAME>
#define INF_IS_XML_CONNECTION(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_XML_CONNECTION))
</MACRO>
<MACRO>
<NAME>INF_XML_CONNECTION_GET_IFACE</NAME>
#define INF_XML_CONNECTION_GET_IFACE(inst)      (G_TYPE_INSTANCE_GET_INTERFACE((inst), INF_TYPE_XML_CONNECTION, InfXmlConnectionIface))
</MACRO>
<MACRO>
<NAME>INF_TYPE_XML_CONNECTION_STATUS</NAME>
#define INF_TYPE_XML_CONNECTION_STATUS          (inf_xml_connection_status_get_type())
</MACRO>
<STRUCT>
<NAME>InfXmlConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>InfXmlConnectionIface</NAME>
</STRUCT>
<ENUM>
<NAME>InfXmlConnectionStatus</NAME>
typedef enum _InfXmlConnectionStatus {
  INF_XML_CONNECTION_CLOSED,
  INF_XML_CONNECTION_CLOSING,
  INF_XML_CONNECTION_OPEN,
  INF_XML_CONNECTION_OPENING
} InfXmlConnectionStatus;
</ENUM>
<STRUCT>
<NAME>InfXmlConnectionIface</NAME>
struct _InfXmlConnectionIface {
  GTypeInterface parent;

  /* Virtual table */
  void (*close)(InfXmlConnection* connection);
  void (*send)(InfXmlConnection* connection,
               xmlNodePtr xml);

  /* Signals */
  void (*sent)(InfXmlConnection* connection,
               const xmlNodePtr xml);
  void (*received)(InfXmlConnection* connection,
                   const xmlNodePtr xml);
  void (*error)(InfXmlConnection* connection,
                const GError* error);
};

</STRUCT>
<FUNCTION>
<NAME>inf_xml_connection_status_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_connection_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_connection_close</NAME>
<RETURNS>void </RETURNS>
InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_connection_send</NAME>
<RETURNS>void </RETURNS>
InfXmlConnection* connection,xmlNodePtr xml
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_connection_sent</NAME>
<RETURNS>void </RETURNS>
InfXmlConnection* connection,const xmlNodePtr xml
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_connection_received</NAME>
<RETURNS>void </RETURNS>
InfXmlConnection* connection,const xmlNodePtr xml
</FUNCTION>
<FUNCTION>
<NAME>inf_xml_connection_error</NAME>
<RETURNS>void </RETURNS>
InfXmlConnection* connection,const GError* error
</FUNCTION>
<MACRO>
<NAME>INF_TYPE_CONNECTION_MANAGER</NAME>
#define INF_TYPE_CONNECTION_MANAGER                 (inf_connection_manager_get_type())
</MACRO>
<MACRO>
<NAME>INF_CONNECTION_MANAGER</NAME>
#define INF_CONNECTION_MANAGER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_TYPE_CONNECTION_MANAGER, InfConnectionManager))
</MACRO>
<MACRO>
<NAME>INF_CONNECTION_MANAGER_CLASS</NAME>
#define INF_CONNECTION_MANAGER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_TYPE_CONNECTION_MANAGER, InfConnectionManagerClass))
</MACRO>
<MACRO>
<NAME>INF_IS_CONNECTION_MANAGER</NAME>
#define INF_IS_CONNECTION_MANAGER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_TYPE_CONNECTION_MANAGER))
</MACRO>
<MACRO>
<NAME>INF_IS_CONNECTION_MANAGER_CLASS</NAME>
#define INF_IS_CONNECTION_MANAGER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_TYPE_CONNECTION_MANAGER))
</MACRO>
<MACRO>
<NAME>INF_CONNECTION_MANAGER_GET_CLASS</NAME>
#define INF_CONNECTION_MANAGER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_TYPE_CONNECTION_MANAGER, InfConnectionManagerClass))
</MACRO>
<MACRO>
<NAME>INF_TYPE_CONNECTION_MANAGER_GROUP</NAME>
#define INF_TYPE_CONNECTION_MANAGER_GROUP           (inf_connection_manager_group_get_type())
</MACRO>
<STRUCT>
<NAME>InfConnectionManager</NAME>
</STRUCT>
<STRUCT>
<NAME>InfConnectionManagerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfConnectionManagerGroup</NAME>
</STRUCT>
<STRUCT>
<NAME>InfConnectionManagerMethod</NAME>
</STRUCT>
<STRUCT>
<NAME>InfConnectionManagerMethodDesc</NAME>
</STRUCT>
<ENUM>
<NAME>InfConnectionManagerScope</NAME>
typedef enum _InfConnectionManagerScope {
  INF_CONNECTION_MANAGER_POINT_TO_POINT,
  INF_CONNECTION_MANAGER_NETWORK,
  INF_CONNECTION_MANAGER_GROUP
} InfConnectionManagerScope;
</ENUM>
<STRUCT>
<NAME>InfConnectionManagerMethodDesc</NAME>
struct _InfConnectionManagerMethodDesc {
  const gchar* network;
  const gchar* name;

  InfConnectionManagerMethod*(*open)(const InfConnectionManagerMethodDesc* dc,
                                     InfConnectionManagerGroup* group);
  InfConnectionManagerMethod*(*join)(const InfConnectionManagerMethodDesc* dc,
                                     InfConnectionManagerGroup* group,
                                     InfXmlConnection* publisher_conn);

  void (*finalize)(InfConnectionManagerMethod* instance);

  /* can_forward specifies whether we can forward this message to other group
   * members. Normally, messages that should only be processed by the
   * recipient should not be forwarded, even if the sender requests this
   * explicitely via scope="group". I'm still wondering whether there are
   * methods that would need to know can_forward. */
  void (*receive_msg)(InfConnectionManagerMethod* instance,
                      InfConnectionManagerScope scope,
                      gboolean can_forward,
                      InfXmlConnection* connection,
                      xmlNodePtr xml);
  void (*receive_ctrl)(InfConnectionManagerMethod* instance,
                       InfXmlConnection* connection,
                       xmlNodePtr xml);

  void (*add_connection)(InfConnectionManagerMethod* instance,
                         InfXmlConnection* connection);
  void (*remove_connection)(InfConnectionManagerMethod* instance,
                            InfXmlConnection* connection);

  /* TODO: Remove this and just rely on registered connections? */
  gboolean (*has_connection)(InfConnectionManagerMethod* instance,
                             InfXmlConnection* connection);
  InfXmlConnection* (*lookup_connection)(InfConnectionManagerMethod* instance,
                                         const gchar* id);

  void (*send_to_net)(InfConnectionManagerMethod* instance,
                      InfXmlConnection* except,
                      xmlNodePtr xml);
};

</STRUCT>
<STRUCT>
<NAME>InfConnectionManagerClass</NAME>
struct _InfConnectionManagerClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfConnectionManager</NAME>
struct _InfConnectionManager {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_connection_manager_group_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_new</NAME>
<RETURNS>InfConnectionManager *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_open_group</NAME>
<RETURNS>InfConnectionManagerGroup *</RETURNS>
InfConnectionManager* manager,const gchar* group_name,InfNetObject* net_object,InfConnectionManagerMethodDesc** methods
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_join_group</NAME>
<RETURNS>InfConnectionManagerGroup *</RETURNS>
InfConnectionManager* manager,const gchar* group_name,InfXmlConnection* publisher_conn,InfNetObject* object,const InfConnectionManagerMethodDesc* meth
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_lookup_group</NAME>
<RETURNS>InfConnectionManagerGroup *</RETURNS>
InfConnectionManager* manager,const gchar* group_name,InfXmlConnection* publisher
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_lookup_group_by_id</NAME>
<RETURNS>InfConnectionManagerGroup *</RETURNS>
InfConnectionManager* manager,const gchar* group_name,const gchar* publisher_id
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_ref</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* group
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_unref</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* group
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_get_method_for_network</NAME>
<RETURNS>const InfConnectionManagerMethodDesc *</RETURNS>
InfConnectionManagerGroup* g,const gchar* network
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_set_object</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* group,InfNetObject* object
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_get_publisher</NAME>
<RETURNS>InfXmlConnection *</RETURNS>
InfConnectionManagerGroup* group
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_get_publisher_id</NAME>
<RETURNS>const gchar *</RETURNS>
InfConnectionManagerGroup* grp
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_has_connection</NAME>
<RETURNS>gboolean </RETURNS>
InfConnectionManagerGroup* group,InfXmlConnection* conn
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
InfConnectionManagerGroup* group
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_add_connection</NAME>
<RETURNS>gboolean </RETURNS>
InfConnectionManagerGroup* group,InfXmlConnection* conn
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_remove_connection</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* grp,InfXmlConnection* conn
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_lookup_connection</NAME>
<RETURNS>InfXmlConnection *</RETURNS>
InfConnectionManagerGroup* grp,const gchar* network,const gchar* id
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_send_to_connection</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* g,InfXmlConnection* connection,xmlNodePtr xml
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_send_to_group</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* group,InfXmlConnection* except,xmlNodePtr xml
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_group_clear_queue</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* group,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_register_connection</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* group,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_unregister_connection</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* group,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_send_msg</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* group,InfXmlConnection* connection,InfConnectionManagerScope scope,xmlNodePtr xml
</FUNCTION>
<FUNCTION>
<NAME>inf_connection_manager_send_ctrl</NAME>
<RETURNS>void </RETURNS>
InfConnectionManagerGroup* group,InfXmlConnection* connection,xmlNodePtr xml
</FUNCTION>
<MACRO>
<NAME>INF_ADOPTED_TYPE_SESSION</NAME>
#define INF_ADOPTED_TYPE_SESSION                 (inf_adopted_session_get_type())
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_SESSION</NAME>
#define INF_ADOPTED_SESSION(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_ADOPTED_TYPE_SESSION, InfAdoptedSession))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_SESSION_CLASS</NAME>
#define INF_ADOPTED_SESSION_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_ADOPTED_TYPE_SESSION, InfAdoptedSessionClass))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_SESSION</NAME>
#define INF_ADOPTED_IS_SESSION(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_ADOPTED_TYPE_SESSION))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_SESSION_CLASS</NAME>
#define INF_ADOPTED_IS_SESSION_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_ADOPTED_TYPE_SESSION))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_SESSION_GET_CLASS</NAME>
#define INF_ADOPTED_SESSION_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_ADOPTED_TYPE_SESSION, InfAdoptedSessionClass))
</MACRO>
<STRUCT>
<NAME>InfAdoptedSession</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedSessionClass</NAME>
</STRUCT>
<ENUM>
<NAME>InfAdoptedSessionError</NAME>
typedef enum _InfAdoptedSessionError {
  INF_ADOPTED_SESSION_ERROR_INVALID_TYPE,
  INF_ADOPTED_SESSION_ERROR_NO_SUCH_USER,
  INF_ADOPTED_SESSION_ERROR_MISSING_OPERATION,
  INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,

  INF_ADOPTED_SESSION_ERROR_MISSING_STATE_VECTOR,
  
  INF_ADOPTED_SESSION_ERROR_FAILED
} InfAdoptedSessionError;
</ENUM>
<STRUCT>
<NAME>InfAdoptedSessionClass</NAME>
struct _InfAdoptedSessionClass {
  InfSessionClass parent_class;

  /* Virtual table */

  xmlNodePtr(*operation_to_xml)(InfAdoptedSession* session,
                                InfAdoptedOperation* operation,
                                gboolean for_sync);

  InfAdoptedOperation*(*xml_to_operation)(InfAdoptedSession* session,
                                          InfAdoptedUser* user,
                                          xmlNodePtr xml,
                                          gboolean for_sync,
                                          GError** error);
};

</STRUCT>
<STRUCT>
<NAME>InfAdoptedSession</NAME>
struct _InfAdoptedSession {
  InfSession parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_adopted_session_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_session_get_io</NAME>
<RETURNS>InfIo *</RETURNS>
InfAdoptedSession* session
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_session_get_algorithm</NAME>
<RETURNS>InfAdoptedAlgorithm *</RETURNS>
InfAdoptedSession* session
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_session_broadcast_request</NAME>
<RETURNS>void </RETURNS>
InfAdoptedSession* session,InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_session_undo</NAME>
<RETURNS>void </RETURNS>
InfAdoptedSession* session,InfAdoptedUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_session_redo</NAME>
<RETURNS>void </RETURNS>
InfAdoptedSession* session,InfAdoptedUser* user
</FUNCTION>
<STRUCT>
<NAME>InfAdoptedUser</NAME>
</STRUCT>
<MACRO>
<NAME>INF_ADOPTED_TYPE_OPERATION</NAME>
#define INF_ADOPTED_TYPE_OPERATION                 (inf_adopted_operation_get_type())
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_OPERATION</NAME>
#define INF_ADOPTED_OPERATION(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_ADOPTED_TYPE_OPERATION, InfAdoptedOperation))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_OPERATION</NAME>
#define INF_ADOPTED_IS_OPERATION(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_ADOPTED_TYPE_OPERATION))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_OPERATION_GET_IFACE</NAME>
#define INF_ADOPTED_OPERATION_GET_IFACE(inst)      (G_TYPE_INSTANCE_GET_INTERFACE((inst), INF_ADOPTED_TYPE_OPERATION, InfAdoptedOperationIface))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_TYPE_OPERATION_FLAGS</NAME>
#define INF_ADOPTED_TYPE_OPERATION_FLAGS           (inf_adopted_operation_flags_get_type())
</MACRO>
<STRUCT>
<NAME>InfAdoptedOperation</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedOperationIface</NAME>
</STRUCT>
<ENUM>
<NAME>InfAdoptedOperationFlags</NAME>
typedef enum _InfAdoptedOperationFlags {
  INF_ADOPTED_OPERATION_AFFECTS_BUFFER = 1 << 0,
  INF_ADOPTED_OPERATION_REVERSIBLE = 1 << 1
} InfAdoptedOperationFlags;
</ENUM>
<STRUCT>
<NAME>InfAdoptedOperationIface</NAME>
struct _InfAdoptedOperationIface {
  GTypeInterface parent;

  InfAdoptedOperation* (*transform)(InfAdoptedOperation* operation,
                                    InfAdoptedOperation* against,
                                    gint concurrency_id);

  InfAdoptedOperation* (*copy)(InfAdoptedOperation* operation);

  InfAdoptedOperationFlags (*get_flags)(InfAdoptedOperation* operation);

  void (*apply)(InfAdoptedOperation* operation,
                InfAdoptedUser* by,
                InfBuffer* buffer);

  InfAdoptedOperation* (*revert)(InfAdoptedOperation* operation);

  /* Some operations may not be reversible, but can be made reversible with
   * some extra information such as another operation that collected
   * information while being transformed and the current buffer.
   *
   * This function should is only called when the opertaion itself is not yet
   * reversible and should return either a reversible operation or NULL if
   * the operation cannot be made reversible. */
  InfAdoptedOperation* (*make_reversible)(InfAdoptedOperation* operation,
                                          InfAdoptedOperation* with,
                                          InfBuffer* buffer);
};

</STRUCT>
<FUNCTION>
<NAME>inf_adopted_operation_flags_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_operation_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_operation_transform</NAME>
<RETURNS>InfAdoptedOperation *</RETURNS>
InfAdoptedOperation* operation,InfAdoptedOperation* against,gint concurrency_id
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_operation_copy</NAME>
<RETURNS>InfAdoptedOperation *</RETURNS>
InfAdoptedOperation* operation
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_operation_get_flags</NAME>
<RETURNS>InfAdoptedOperationFlags </RETURNS>
InfAdoptedOperation* operation
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_operation_apply</NAME>
<RETURNS>void </RETURNS>
InfAdoptedOperation* operation,InfAdoptedUser* by,InfBuffer* buffer
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_operation_is_reversible</NAME>
<RETURNS>gboolean </RETURNS>
InfAdoptedOperation* operation
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_operation_revert</NAME>
<RETURNS>InfAdoptedOperation *</RETURNS>
InfAdoptedOperation* operation
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_operation_make_reversible</NAME>
<RETURNS>InfAdoptedOperation *</RETURNS>
InfAdoptedOperation* operation,InfAdoptedOperation* with,InfBuffer* buffer
</FUNCTION>
<MACRO>
<NAME>INF_ADOPTED_TYPE_STATE_VECTOR</NAME>
#define INF_ADOPTED_TYPE_STATE_VECTOR            (inf_adopted_state_vector_get_type())
</MACRO>
<TYPEDEF>
<NAME>InfAdoptedStateVector</NAME>
typedef GSequence InfAdoptedStateVector;
</TYPEDEF>
<ENUM>
<NAME>InfAdoptedStateVectorError</NAME>
typedef enum _InfAdoptedStateVectorError {
  INF_ADOPTED_STATE_VECTOR_BAD_FORMAT,

  INF_ADOPTED_STATE_VECTOR_FAILED
} InfAdoptedStateVectorError;
</ENUM>
<USER_FUNCTION>
<NAME>InfAdoptedStateVectorForeachFunc</NAME>
<RETURNS>void </RETURNS>
guint id,
                                                guint value,
                                                gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_new</NAME>
<RETURNS>InfAdoptedStateVector *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_copy</NAME>
<RETURNS>InfAdoptedStateVector *</RETURNS>
InfAdoptedStateVector* vec
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_free</NAME>
<RETURNS>void </RETURNS>
InfAdoptedStateVector* vec
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_get</NAME>
<RETURNS>guint </RETURNS>
InfAdoptedStateVector* vec,guint id
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_set</NAME>
<RETURNS>void </RETURNS>
InfAdoptedStateVector* vec,guint id,guint value
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_add</NAME>
<RETURNS>void </RETURNS>
InfAdoptedStateVector* vec,guint id,gint value
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_foreach</NAME>
<RETURNS>void </RETURNS>
InfAdoptedStateVector* vec,InfAdoptedStateVectorForeachFunc func,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_compare</NAME>
<RETURNS>int </RETURNS>
InfAdoptedStateVector* first,InfAdoptedStateVector* second
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_causally_before</NAME>
<RETURNS>gboolean </RETURNS>
InfAdoptedStateVector* first,InfAdoptedStateVector* second
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_to_string</NAME>
<RETURNS>gchar *</RETURNS>
InfAdoptedStateVector* vec
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_from_string</NAME>
<RETURNS>InfAdoptedStateVector *</RETURNS>
const gchar* str,GError** error
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_to_string_diff</NAME>
<RETURNS>gchar *</RETURNS>
InfAdoptedStateVector* vec,InfAdoptedStateVector* orig
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_state_vector_from_string_diff</NAME>
<RETURNS>InfAdoptedStateVector *</RETURNS>
const gchar* str,InfAdoptedStateVector* orig,GError** error
</FUNCTION>
<MACRO>
<NAME>INF_ADOPTED_TYPE_USER</NAME>
#define INF_ADOPTED_TYPE_USER                 (inf_adopted_user_get_type())
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_USER</NAME>
#define INF_ADOPTED_USER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_ADOPTED_TYPE_USER, InfAdoptedUser))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_USER_CLASS</NAME>
#define INF_ADOPTED_USER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_ADOPTED_TYPE_USER, InfAdoptedUserClass))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_USER</NAME>
#define INF_ADOPTED_IS_USER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_ADOPTED_TYPE_USER))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_USER_CLASS</NAME>
#define INF_ADOPTED_IS_USER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_ADOPTED_TYPE_USER))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_USER_GET_CLASS</NAME>
#define INF_ADOPTED_USER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_ADOPTED_TYPE_USER, InfAdoptedUserClass))
</MACRO>
<STRUCT>
<NAME>InfAdoptedUserClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedUserClass</NAME>
struct _InfAdoptedUserClass {
  InfUserClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfAdoptedUser</NAME>
struct _InfAdoptedUser {
  InfUser parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_adopted_user_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_user_get_component</NAME>
<RETURNS>guint </RETURNS>
InfAdoptedUser* user,guint id
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_user_get_vector</NAME>
<RETURNS>InfAdoptedStateVector *</RETURNS>
InfAdoptedUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_user_set_vector</NAME>
<RETURNS>void </RETURNS>
InfAdoptedUser* user,InfAdoptedStateVector* vec
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_user_get_request_log</NAME>
<RETURNS>InfAdoptedRequestLog *</RETURNS>
InfAdoptedUser* user
</FUNCTION>
<MACRO>
<NAME>INF_ADOPTED_TYPE_REQUEST</NAME>
#define INF_ADOPTED_TYPE_REQUEST                 (inf_adopted_request_get_type())
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_REQUEST</NAME>
#define INF_ADOPTED_REQUEST(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_ADOPTED_TYPE_REQUEST, InfAdoptedRequest))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_REQUEST_CLASS</NAME>
#define INF_ADOPTED_REQUEST_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_ADOPTED_TYPE_REQUEST, InfAdoptedRequestClass))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_REQUEST</NAME>
#define INF_ADOPTED_IS_REQUEST(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_ADOPTED_TYPE_REQUEST))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_REQUEST_CLASS</NAME>
#define INF_ADOPTED_IS_REQUEST_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_ADOPTED_TYPE_REQUEST))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_REQUEST_GET_CLASS</NAME>
#define INF_ADOPTED_REQUEST_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_ADOPTED_TYPE_REQUEST, InfAdoptedRequestClass))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_TYPE_REQUEST_TYPE</NAME>
#define INF_ADOPTED_TYPE_REQUEST_TYPE            (inf_adopted_request_type_get_type())
</MACRO>
<STRUCT>
<NAME>InfAdoptedRequest</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedRequestClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedRequestClass</NAME>
struct _InfAdoptedRequestClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfAdoptedRequest</NAME>
struct _InfAdoptedRequest {
  GObject parent;
};

</STRUCT>
<ENUM>
<NAME>InfAdoptedRequestType</NAME>
typedef enum _InfAdoptedRequestType {
  INF_ADOPTED_REQUEST_DO,
  INF_ADOPTED_REQUEST_UNDO,
  INF_ADOPTED_REQUEST_REDO
} InfAdoptedRequestType;
</ENUM>
<FUNCTION>
<NAME>inf_adopted_request_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_new_do</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedStateVector* vector,guint user_id,InfAdoptedOperation* operation
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_new_undo</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedStateVector* vector,guint user_id
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_new_redo</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedStateVector* vector,guint user_id
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_copy</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_get_request_type</NAME>
<RETURNS>InfAdoptedRequestType </RETURNS>
InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_get_vector</NAME>
<RETURNS>InfAdoptedStateVector *</RETURNS>
InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_get_user_id</NAME>
<RETURNS>guint </RETURNS>
InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_get_operation</NAME>
<RETURNS>InfAdoptedOperation *</RETURNS>
InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_transform</NAME>
<RETURNS>void </RETURNS>
InfAdoptedRequest* request,InfAdoptedRequest* against
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_mirror</NAME>
<RETURNS>void </RETURNS>
InfAdoptedRequest* request,guint by
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_fold</NAME>
<RETURNS>void </RETURNS>
InfAdoptedRequest* request,guint into,guint by
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_affects_buffer</NAME>
<RETURNS>gboolean </RETURNS>
InfAdoptedRequest* request
</FUNCTION>
<MACRO>
<NAME>INF_ADOPTED_TYPE_ALGORITHM</NAME>
#define INF_ADOPTED_TYPE_ALGORITHM                 (inf_adopted_algorithm_get_type())
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_ALGORITHM</NAME>
#define INF_ADOPTED_ALGORITHM(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_ADOPTED_TYPE_ALGORITHM, InfAdoptedAlgorithm))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_ALGORITHM_CLASS</NAME>
#define INF_ADOPTED_ALGORITHM_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_ADOPTED_TYPE_ALGORITHM, InfAdoptedAlgorithmClass))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_ALGORITHM</NAME>
#define INF_ADOPTED_IS_ALGORITHM(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_ADOPTED_TYPE_ALGORITHM))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_ALGORITHM_CLASS</NAME>
#define INF_ADOPTED_IS_ALGORITHM_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_ADOPTED_TYPE_ALGORITHM))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_ALGORITHM_GET_CLASS</NAME>
#define INF_ADOPTED_ALGORITHM_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_ADOPTED_TYPE_ALGORITHM, InfAdoptedAlgorithmClass))
</MACRO>
<STRUCT>
<NAME>InfAdoptedAlgorithm</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedAlgorithmClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedAlgorithmClass</NAME>
struct _InfAdoptedAlgorithmClass {
  GObjectClass parent_class;

  /* Signals */

  void(*can_undo_changed)(InfAdoptedAlgorithm* algorithm,
                          InfAdoptedUser* user,
                          gboolean can_undo);

  void(*can_redo_changed)(InfAdoptedAlgorithm* algorithm,
                          InfAdoptedUser* user,
                          gboolean can_redo);

  void(*apply_request)(InfAdoptedAlgorithm* algorithm,
                       InfAdoptedUser* user,
                       InfAdoptedRequest* request);
};

</STRUCT>
<STRUCT>
<NAME>InfAdoptedAlgorithm</NAME>
struct _InfAdoptedAlgorithm {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_adopted_algorithm_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_algorithm_new</NAME>
<RETURNS>InfAdoptedAlgorithm *</RETURNS>
InfUserTable* user_table,InfBuffer* buffer
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_algorithm_new_full</NAME>
<RETURNS>InfAdoptedAlgorithm *</RETURNS>
InfUserTable* user_table,InfBuffer* buffer,guint max_total_log_size
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_algorithm_get_current</NAME>
<RETURNS>InfAdoptedStateVector *</RETURNS>
InfAdoptedAlgorithm* algorithm
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_algorithm_generate_request_noexec</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedAlgorithm* algorithm,InfAdoptedUser* user,InfAdoptedOperation* operation
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_algorithm_generate_request</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedAlgorithm* algorithm,InfAdoptedUser* user,InfAdoptedOperation* operation
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_algorithm_generate_undo</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedAlgorithm* algorithm,InfAdoptedUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_algorithm_generate_redo</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedAlgorithm* algorithm,InfAdoptedUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_algorithm_receive_request</NAME>
<RETURNS>void </RETURNS>
InfAdoptedAlgorithm* algorithm,InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_algorithm_can_undo</NAME>
<RETURNS>gboolean </RETURNS>
InfAdoptedAlgorithm* algorithm,InfAdoptedUser* user
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_algorithm_can_redo</NAME>
<RETURNS>gboolean </RETURNS>
InfAdoptedAlgorithm* algorithm,InfAdoptedUser* user
</FUNCTION>
<MACRO>
<NAME>INF_ADOPTED_TYPE_SPLIT_OPERATION</NAME>
#define INF_ADOPTED_TYPE_SPLIT_OPERATION                 (inf_adopted_split_operation_get_type())
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_SPLIT_OPERATION</NAME>
#define INF_ADOPTED_SPLIT_OPERATION(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_ADOPTED_TYPE_SPLIT_OPERATION, InfAdoptedSplitOperation))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_SPLIT_OPERATION_CLASS</NAME>
#define INF_ADOPTED_SPLIT_OPERATION_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_ADOPTED_TYPE_SPLIT_OPERATION, InfAdoptedSplitOperationClass))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_SPLIT_OPERATION</NAME>
#define INF_ADOPTED_IS_SPLIT_OPERATION(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_ADOPTED_TYPE_SPLIT_OPERATION))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_SPLIT_OPERATION_CLASS</NAME>
#define INF_ADOPTED_IS_SPLIT_OPERATION_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_ADOPTED_TYPE_SPLIT_OPERATION))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_SPLIT_OPERATION_GET_CLASS</NAME>
#define INF_ADOPTED_SPLIT_OPERATION_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_ADOPTED_TYPE_SPLIT_OPERATION, InfAdoptedSplitOperationClass))
</MACRO>
<STRUCT>
<NAME>InfAdoptedSplitOperation</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedSplitOperationClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedSplitOperationClass</NAME>
struct _InfAdoptedSplitOperationClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfAdoptedSplitOperation</NAME>
struct _InfAdoptedSplitOperation {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_adopted_split_operation_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_split_operation_new</NAME>
<RETURNS>InfAdoptedSplitOperation *</RETURNS>
InfAdoptedOperation* first,InfAdoptedOperation* second
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_split_operation_unsplit</NAME>
<RETURNS>GSList *</RETURNS>
InfAdoptedSplitOperation* operation
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_split_operation_transform_other</NAME>
<RETURNS>InfAdoptedOperation *</RETURNS>
InfAdoptedSplitOperation* op,InfAdoptedOperation* other,gint concurrency_id
</FUNCTION>
<MACRO>
<NAME>INF_ADOPTED_TYPE_NO_OPERATION</NAME>
#define INF_ADOPTED_TYPE_NO_OPERATION                 (inf_adopted_no_operation_get_type())
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_NO_OPERATION</NAME>
#define INF_ADOPTED_NO_OPERATION(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_ADOPTED_TYPE_NO_OPERATION, InfAdoptedNoOperation))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_NO_OPERATION_CLASS</NAME>
#define INF_ADOPTED_NO_OPERATION_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_ADOPTED_TYPE_NO_OPERATION, InfAdoptedNoOperationClass))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_NO_OPERATION</NAME>
#define INF_ADOPTED_IS_NO_OPERATION(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_ADOPTED_TYPE_NO_OPERATION))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_NO_OPERATION_CLASS</NAME>
#define INF_ADOPTED_IS_NO_OPERATION_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_ADOPTED_TYPE_NO_OPERATION))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_NO_OPERATION_GET_CLASS</NAME>
#define INF_ADOPTED_NO_OPERATION_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_ADOPTED_TYPE_NO_OPERATION, InfAdoptedNoOperationClass))
</MACRO>
<STRUCT>
<NAME>InfAdoptedNoOperation</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedNoOperationClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedNoOperationClass</NAME>
struct _InfAdoptedNoOperationClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfAdoptedNoOperation</NAME>
struct _InfAdoptedNoOperation {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_adopted_no_operation_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_no_operation_new</NAME>
<RETURNS>InfAdoptedNoOperation *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>INF_ADOPTED_TYPE_REQUEST_LOG</NAME>
#define INF_ADOPTED_TYPE_REQUEST_LOG                 (inf_adopted_request_log_get_type())
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_REQUEST_LOG</NAME>
#define INF_ADOPTED_REQUEST_LOG(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INF_ADOPTED_TYPE_REQUEST_LOG, InfAdoptedRequestLog))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_REQUEST_LOG_CLASS</NAME>
#define INF_ADOPTED_REQUEST_LOG_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INF_ADOPTED_TYPE_REQUEST_LOG, InfAdoptedRequestLogClass))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_REQUEST_LOG</NAME>
#define INF_ADOPTED_IS_REQUEST_LOG(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INF_ADOPTED_TYPE_REQUEST_LOG))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_IS_REQUEST_LOG_CLASS</NAME>
#define INF_ADOPTED_IS_REQUEST_LOG_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INF_ADOPTED_TYPE_REQUEST_LOG))
</MACRO>
<MACRO>
<NAME>INF_ADOPTED_REQUEST_LOG_GET_CLASS</NAME>
#define INF_ADOPTED_REQUEST_LOG_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INF_ADOPTED_TYPE_REQUEST_LOG, InfAdoptedRequestLogClass))
</MACRO>
<STRUCT>
<NAME>InfAdoptedRequestLog</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedRequestLogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfAdoptedRequestLogClass</NAME>
struct _InfAdoptedRequestLogClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfAdoptedRequestLog</NAME>
struct _InfAdoptedRequestLog {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>inf_adopted_request_log_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_new</NAME>
<RETURNS>InfAdoptedRequestLog *</RETURNS>
guint user_id
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_get_user_id</NAME>
<RETURNS>guint </RETURNS>
InfAdoptedRequestLog* log
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_get_begin</NAME>
<RETURNS>guint </RETURNS>
InfAdoptedRequestLog* log
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_get_end</NAME>
<RETURNS>guint </RETURNS>
InfAdoptedRequestLog* log
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_get_request</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedRequestLog* log,guint n
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_add_request</NAME>
<RETURNS>void </RETURNS>
InfAdoptedRequestLog* log,InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_remove_requests</NAME>
<RETURNS>void </RETURNS>
InfAdoptedRequestLog* log,guint up_to
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_next_associated</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedRequestLog* log,InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_prev_associated</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedRequestLog* log,InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_original_request</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedRequestLog* log,InfAdoptedRequest* request
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_next_undo</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedRequestLog* log
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_next_redo</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedRequestLog* log
</FUNCTION>
<FUNCTION>
<NAME>inf_adopted_request_log_upper_related</NAME>
<RETURNS>InfAdoptedRequest *</RETURNS>
InfAdoptedRequestLog* log,guint n
</FUNCTION>
<MACRO>
<NAME>INFD_TYPE_XMPP_SERVER</NAME>
#define INFD_TYPE_XMPP_SERVER                 (infd_xmpp_server_get_type())
</MACRO>
<MACRO>
<NAME>INFD_XMPP_SERVER</NAME>
#define INFD_XMPP_SERVER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFD_TYPE_XMPP_SERVER, InfdXmppServer))
</MACRO>
<MACRO>
<NAME>INFD_XMPP_SERVER_CLASS</NAME>
#define INFD_XMPP_SERVER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFD_TYPE_XMPP_SERVER, InfdXmppServerClass))
</MACRO>
<MACRO>
<NAME>INFD_IS_XMPP_SERVER</NAME>
#define INFD_IS_XMPP_SERVER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFD_TYPE_XMPP_SERVER))
</MACRO>
<MACRO>
<NAME>INFD_IS_XMPP_SERVER_CLASS</NAME>
#define INFD_IS_XMPP_SERVER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFD_TYPE_XMPP_SERVER))
</MACRO>
<MACRO>
<NAME>INFD_XMPP_SERVER_GET_CLASS</NAME>
#define INFD_XMPP_SERVER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFD_TYPE_XMPP_SERVER, InfdXmppServerClass))
</MACRO>
<STRUCT>
<NAME>InfdXmppServer</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdXmppServerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdXmppServerClass</NAME>
struct _InfdXmppServerClass {
  GObjectClass parent_class;

  /* Signals */
  void (*error)(InfdXmppServer* server,
                GError* error);
};

</STRUCT>
<STRUCT>
<NAME>InfdXmppServer</NAME>
struct _InfdXmppServer {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>infd_xmpp_server_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_xmpp_server_new</NAME>
<RETURNS>InfdXmppServer *</RETURNS>
InfdTcpServer* tcp,const gchar* jid,gnutls_certificate_credentials_t cred,Gsasl* sasl_context
</FUNCTION>
<MACRO>
<NAME>INFD_TYPE_SERVER_POOL</NAME>
#define INFD_TYPE_SERVER_POOL                 (infd_server_pool_get_type())
</MACRO>
<MACRO>
<NAME>INFD_SERVER_POOL</NAME>
#define INFD_SERVER_POOL(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFD_TYPE_SERVER_POOL, InfdServerPool))
</MACRO>
<MACRO>
<NAME>INFD_SERVER_POOL_CLASS</NAME>
#define INFD_SERVER_POOL_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFD_TYPE_SERVER_POOL, InfdServerPoolClass))
</MACRO>
<MACRO>
<NAME>INFD_IS_SERVER_POOL</NAME>
#define INFD_IS_SERVER_POOL(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFD_TYPE_SERVER_POOL))
</MACRO>
<MACRO>
<NAME>INFD_IS_SERVER_POOL_CLASS</NAME>
#define INFD_IS_SERVER_POOL_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFD_TYPE_SERVER_POOL))
</MACRO>
<MACRO>
<NAME>INFD_SERVER_POOL_GET_CLASS</NAME>
#define INFD_SERVER_POOL_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFD_TYPE_SERVER_POOL, InfdServerPoolClass))
</MACRO>
<STRUCT>
<NAME>InfdServerPool</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdServerPoolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdServerPoolClass</NAME>
struct _InfdServerPoolClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfdServerPool</NAME>
struct _InfdServerPool {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>infd_server_pool_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_server_pool_new</NAME>
<RETURNS>InfdServerPool *</RETURNS>
InfdDirectory* directory
</FUNCTION>
<FUNCTION>
<NAME>infd_server_pool_add_server</NAME>
<RETURNS>void </RETURNS>
InfdServerPool* server_pool,InfdXmlServer* server
</FUNCTION>
<FUNCTION>
<NAME>infd_server_pool_add_local_publisher</NAME>
<RETURNS>void </RETURNS>
InfdServerPool* server_pool,InfdXmppServer* server,InfLocalPublisher* publisher
</FUNCTION>
<STRUCT>
<NAME>InfdNotePlugin</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdNotePlugin</NAME>
struct _InfdNotePlugin {
  /* The typename of the storage backend this plugin can be used with, such
   * as InfdFilesystemStorage. */
  const gchar* storage_type;

  /* The note type this plugin handles, such as InfText */
  const gchar* note_type;

  InfSession*(*session_new)(InfIo* io,
                            InfConnectionManager* manager,
                            InfConnectionManagerGroup* group,
                            InfXmlConnection* sync_connection);

  InfSession*(*session_read)(InfdStorage* storage,
                             InfIo* io,
                             InfConnectionManager* manager,
                             const gchar* path,
                             GError** error);

  gboolean(*session_write)(InfdStorage* storage,
                           InfSession* session,
                           const gchar* path,
                           GError** error);
};

</STRUCT>
<MACRO>
<NAME>INFD_TYPE_DIRECTORY</NAME>
#define INFD_TYPE_DIRECTORY                 (infd_directory_get_type())
</MACRO>
<MACRO>
<NAME>INFD_DIRECTORY</NAME>
#define INFD_DIRECTORY(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFD_TYPE_DIRECTORY, InfdDirectory))
</MACRO>
<MACRO>
<NAME>INFD_DIRECTORY_CLASS</NAME>
#define INFD_DIRECTORY_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFD_TYPE_DIRECTORY, InfdDirectoryClass))
</MACRO>
<MACRO>
<NAME>INFD_IS_DIRECTORY</NAME>
#define INFD_IS_DIRECTORY(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFD_TYPE_DIRECTORY))
</MACRO>
<MACRO>
<NAME>INFD_IS_DIRECTORY_CLASS</NAME>
#define INFD_IS_DIRECTORY_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFD_TYPE_DIRECTORY))
</MACRO>
<MACRO>
<NAME>INFD_DIRECTORY_GET_CLASS</NAME>
#define INFD_DIRECTORY_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFD_TYPE_DIRECTORY, InfdDirectoryClass))
</MACRO>
<MACRO>
<NAME>INFD_TYPE_DIRECTORY_ITER</NAME>
#define INFD_TYPE_DIRECTORY_ITER            (infd_directory_iter_get_type())
</MACRO>
<STRUCT>
<NAME>InfdDirectory</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdDirectoryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdDirectoryIter</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdDirectoryIter</NAME>
struct _InfdDirectoryIter {
  guint node_id;
  gpointer node;
};

</STRUCT>
<STRUCT>
<NAME>InfdDirectoryClass</NAME>
struct _InfdDirectoryClass {
  GObjectClass parent_class;

  /* Signals */
  void (*node_added)(InfdDirectory* directory,
                     InfdDirectoryIter* iter);

  void (*node_removed)(InfdDirectory* directory,
                       InfdDirectoryIter* iter);
};

</STRUCT>
<STRUCT>
<NAME>InfdDirectory</NAME>
struct _InfdDirectory {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>infd_directory_iter_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_iter_copy</NAME>
<RETURNS>InfdDirectoryIter *</RETURNS>
InfdDirectoryIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_iter_free</NAME>
<RETURNS>void </RETURNS>
InfdDirectoryIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_new</NAME>
<RETURNS>InfdDirectory *</RETURNS>
InfIo* io,InfdStorage* storage,InfConnectionManager* connection_manager,InfMethodManager* method_manager
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_get_io</NAME>
<RETURNS>InfIo *</RETURNS>
InfdDirectory* directory
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_get_storage</NAME>
<RETURNS>InfdStorage *</RETURNS>
InfdDirectory* directory
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_get_connection_manager</NAME>
<RETURNS>InfConnectionManager *</RETURNS>
InfdDirectory* directory
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_add_plugin</NAME>
<RETURNS>gboolean </RETURNS>
InfdDirectory* directory,const InfdNotePlugin* plugin
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_lookup_plugin</NAME>
<RETURNS>const InfdNotePlugin *</RETURNS>
InfdDirectory* directory,const gchar* note_type
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_add_connection</NAME>
<RETURNS>gboolean </RETURNS>
InfdDirectory* directory,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_iter_get_root</NAME>
<RETURNS>void </RETURNS>
InfdDirectory* directory,InfdDirectoryIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_iter_get_next</NAME>
<RETURNS>gboolean </RETURNS>
InfdDirectory* directory,InfdDirectoryIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_iter_get_prev</NAME>
<RETURNS>gboolean </RETURNS>
InfdDirectory* directory,InfdDirectoryIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_iter_get_parent</NAME>
<RETURNS>gboolean </RETURNS>
InfdDirectory* directory,InfdDirectoryIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_iter_get_child</NAME>
<RETURNS>gboolean </RETURNS>
InfdDirectory* directory,InfdDirectoryIter* iter,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_add_subdirectory</NAME>
<RETURNS>gboolean </RETURNS>
InfdDirectory* directory,InfdDirectoryIter* parent,const gchar* name,InfdDirectoryIter* iter,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_add_note</NAME>
<RETURNS>gboolean </RETURNS>
InfdDirectory* directory,InfdDirectoryIter* parent,const gchar* name,InfdNotePlugin* plugin,InfdDirectoryIter* iter,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_remove_node</NAME>
<RETURNS>gboolean </RETURNS>
InfdDirectory* directory,InfdDirectoryIter* iter,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_iter_get_node_type</NAME>
<RETURNS>InfdStorageNodeType </RETURNS>
InfdDirectory* directory,InfdDirectoryIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_iter_get_plugin</NAME>
<RETURNS>InfdNotePlugin *</RETURNS>
InfdDirectory* directory,InfdDirectoryIter* iter
</FUNCTION>
<FUNCTION>
<NAME>infd_directory_iter_get_session</NAME>
<RETURNS>InfdSessionProxy *</RETURNS>
InfdDirectory* directory,InfdDirectoryIter* iter,GError** error
</FUNCTION>
<MACRO>
<NAME>INFD_TYPE_XML_SERVER</NAME>
#define INFD_TYPE_XML_SERVER                 (infd_xml_server_get_type())
</MACRO>
<MACRO>
<NAME>INFD_XML_SERVER</NAME>
#define INFD_XML_SERVER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFD_TYPE_XML_SERVER, InfdXmlServer))
</MACRO>
<MACRO>
<NAME>INFD_IS_XML_SERVER</NAME>
#define INFD_IS_XML_SERVER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFD_TYPE_XML_SERVER))
</MACRO>
<MACRO>
<NAME>INFD_XML_SERVER_GET_IFACE</NAME>
#define INFD_XML_SERVER_GET_IFACE(inst)      (G_TYPE_INSTANCE_GET_INTERFACE((inst), INFD_TYPE_XML_SERVER, InfdXmlServerIface))
</MACRO>
<MACRO>
<NAME>INFD_TYPE_XML_SERVER_STATUS</NAME>
#define INFD_TYPE_XML_SERVER_STATUS          (infd_xml_server_status_get_type())
</MACRO>
<STRUCT>
<NAME>InfdXmlServer</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdXmlServerIface</NAME>
</STRUCT>
<ENUM>
<NAME>InfdXmlServerStatus</NAME>
typedef enum _InfdXmlServerStatus {
  INFD_XML_SERVER_CLOSED,
  INFD_XML_SERVER_CLOSING,
  INFD_XML_SERVER_OPEN,
  INFD_XML_SERVER_OPENING
} InfdXmlServerStatus;
</ENUM>
<STRUCT>
<NAME>InfdXmlServerIface</NAME>
struct _InfdXmlServerIface {
  GTypeInterface parent;

  /* Virtual Table */
  void (*close)(InfdXmlServer* server);

  /* Signals */
  void (*new_connection)(InfdXmlServer* server,
                         InfXmlConnection* connection);
};

</STRUCT>
<FUNCTION>
<NAME>infd_xml_server_status_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_xml_server_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_xml_server_close</NAME>
<RETURNS>void </RETURNS>
InfdXmlServer* server
</FUNCTION>
<FUNCTION>
<NAME>infd_xml_server_new_connection</NAME>
<RETURNS>void </RETURNS>
InfdXmlServer* server,InfXmlConnection* connection
</FUNCTION>
<MACRO>
<NAME>INFD_TYPE_TCP_SERVER</NAME>
#define INFD_TYPE_TCP_SERVER                 (infd_tcp_server_get_type())
</MACRO>
<MACRO>
<NAME>INFD_TCP_SERVER</NAME>
#define INFD_TCP_SERVER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFD_TYPE_TCP_SERVER, InfdTcpServer))
</MACRO>
<MACRO>
<NAME>INFD_TCP_SERVER_CLASS</NAME>
#define INFD_TCP_SERVER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFD_TYPE_TCP_SERVER, InfdTcpServerClass))
</MACRO>
<MACRO>
<NAME>INFD_IS_TCP_SERVER</NAME>
#define INFD_IS_TCP_SERVER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFD_TYPE_TCP_SERVER))
</MACRO>
<MACRO>
<NAME>INFD_IS_TCP_SERVER_CLASS</NAME>
#define INFD_IS_TCP_SERVER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFD_TYPE_TCP_SERVER))
</MACRO>
<MACRO>
<NAME>INFD_TCP_SERVER_GET_CLASS</NAME>
#define INFD_TCP_SERVER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFD_TYPE_TCP_SERVER, InfdTcpServerClass))
</MACRO>
<MACRO>
<NAME>INFD_TYPE_TCP_SERVER_STATUS</NAME>
#define INFD_TYPE_TCP_SERVER_STATUS          (infd_tcp_server_status_get_type())
</MACRO>
<STRUCT>
<NAME>InfdTcpServer</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdTcpServerClass</NAME>
</STRUCT>
<ENUM>
<NAME>InfdTcpServerStatus</NAME>
typedef enum _InfdTcpServerStatus {
  INFD_TCP_SERVER_CLOSED,
  INFD_TCP_SERVER_OPEN
} InfdTcpServerStatus;
</ENUM>
<STRUCT>
<NAME>InfdTcpServerClass</NAME>
struct _InfdTcpServerClass {
  GObjectClass parent_class;

  /* Signals */
  void (*new_connection)(InfdTcpServer* server,
                         InfTcpConnection* connection);

  void (*error)(InfdTcpServer* server,
                GError* error);
};

</STRUCT>
<STRUCT>
<NAME>InfdTcpServer</NAME>
struct _InfdTcpServer {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>infd_tcp_server_status_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_tcp_server_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_tcp_server_open</NAME>
<RETURNS>gboolean </RETURNS>
InfdTcpServer* server,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infd_tcp_server_close</NAME>
<RETURNS>void </RETURNS>
InfdTcpServer* server
</FUNCTION>
<MACRO>
<NAME>INFD_TYPE_STORAGE</NAME>
#define INFD_TYPE_STORAGE                 (infd_storage_get_type())
</MACRO>
<MACRO>
<NAME>INFD_STORAGE</NAME>
#define INFD_STORAGE(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFD_TYPE_STORAGE, InfdStorage))
</MACRO>
<MACRO>
<NAME>INFD_IS_STORAGE</NAME>
#define INFD_IS_STORAGE(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFD_TYPE_STORAGE))
</MACRO>
<MACRO>
<NAME>INFD_STORAGE_GET_IFACE</NAME>
#define INFD_STORAGE_GET_IFACE(inst)      (G_TYPE_INSTANCE_GET_INTERFACE((inst), INFD_TYPE_STORAGE, InfdStorageIface))
</MACRO>
<MACRO>
<NAME>INFD_TYPE_STORAGE_NODE_TYPE</NAME>
#define INFD_TYPE_STORAGE_NODE_TYPE       (infd_storage_node_type_get_type())
</MACRO>
<MACRO>
<NAME>INFD_TYPE_STORAGE_NODE</NAME>
#define INFD_TYPE_STORAGE_NODE            (infd_storage_node_get_type())
</MACRO>
<STRUCT>
<NAME>InfdStorage</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdStorageIface</NAME>
</STRUCT>
<ENUM>
<NAME>InfdStorageNodeType</NAME>
typedef enum _InfdStorageNodeType {
  INFD_STORAGE_NODE_SUBDIRECTORY,
  INFD_STORAGE_NODE_NOTE
} InfdStorageNodeType;
</ENUM>
<STRUCT>
<NAME>InfdStorageNode</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdStorageNode</NAME>
struct _InfdStorageNode {
  InfdStorageNodeType type;
  gchar* name;

  gchar* identifier; /* Only set when type == INFD_STORAGE_NODE_NOTE */
};

</STRUCT>
<STRUCT>
<NAME>InfdStorageIface</NAME>
struct _InfdStorageIface {
  GTypeInterface parent;

  /* All these calls are supposed to be synchronous, e.g. completly perform
   * the required task. Some day, we could implement asynchronous
   * behaviour in InfdDirectory (e.g. it caches operations and executes
   * them via the storage in the background). */

  /* Virtual Table */
  GSList* (*read_subdirectory)(InfdStorage* storage,
                               const gchar* path,
                               GError** error);

  gboolean (*create_subdirectory)(InfdStorage* storage,
                                  const gchar* path,
                                  GError** error);

  gboolean (*remove_node)(InfdStorage* storage,
                          const gchar* path,
                          GError** error);

  /* TODO: Add further methods to copy, move and expunge nodes */
  /* TODO: Notification? */
};

</STRUCT>
<FUNCTION>
<NAME>infd_storage_node_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_storage_node_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_storage_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_storage_node_new_subdirectory</NAME>
<RETURNS>InfdStorageNode *</RETURNS>
const gchar* path
</FUNCTION>
<FUNCTION>
<NAME>infd_storage_node_new_note</NAME>
<RETURNS>InfdStorageNode *</RETURNS>
const gchar* path,const gchar* identifier
</FUNCTION>
<FUNCTION>
<NAME>infd_storage_node_copy</NAME>
<RETURNS>InfdStorageNode *</RETURNS>
InfdStorageNode* node
</FUNCTION>
<FUNCTION>
<NAME>infd_storage_node_free</NAME>
<RETURNS>void </RETURNS>
InfdStorageNode* node
</FUNCTION>
<FUNCTION>
<NAME>infd_storage_node_list_free</NAME>
<RETURNS>void </RETURNS>
GSList* node_list
</FUNCTION>
<FUNCTION>
<NAME>infd_storage_read_subdirectory</NAME>
<RETURNS>GSList *</RETURNS>
InfdStorage* storage,const gchar* path,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infd_storage_create_subdirectory</NAME>
<RETURNS>gboolean </RETURNS>
InfdStorage* storage,const gchar* path,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infd_storage_remove_node</NAME>
<RETURNS>gboolean </RETURNS>
InfdStorage* storage,const gchar* path,GError** error
</FUNCTION>
<MACRO>
<NAME>INFD_TYPE_SESSION_PROXY</NAME>
#define INFD_TYPE_SESSION_PROXY                 (infd_session_proxy_get_type())
</MACRO>
<MACRO>
<NAME>INFD_SESSION_PROXY</NAME>
#define INFD_SESSION_PROXY(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFD_TYPE_SESSION_PROXY, InfdSessionProxy))
</MACRO>
<MACRO>
<NAME>INFD_SESSION_PROXY_CLASS</NAME>
#define INFD_SESSION_PROXY_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFD_TYPE_SESSION_PROXY, InfdSessionProxyClass))
</MACRO>
<MACRO>
<NAME>INFD_IS_SESSION_PROXY</NAME>
#define INFD_IS_SESSION_PROXY(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFD_TYPE_SESSION_PROXY))
</MACRO>
<MACRO>
<NAME>INFD_IS_SESSION_PROXY_CLASS</NAME>
#define INFD_IS_SESSION_PROXY_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFD_TYPE_SESSION_PROXY))
</MACRO>
<MACRO>
<NAME>INFD_SESSION_PROXY_GET_CLASS</NAME>
#define INFD_SESSION_PROXY_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFD_TYPE_SESSION_PROXY, InfdSessionProxyClass))
</MACRO>
<STRUCT>
<NAME>InfdSessionProxy</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdSessionProxyClass</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdSessionProxyClass</NAME>
struct _InfdSessionProxyClass {
  GObjectClass parent_class;

  /* Signals */
  void (*add_subscription)(InfdSessionProxy* proxy,
                           InfXmlConnection* connection);

  void (*remove_subscription)(InfdSessionProxy* proxy,
                              InfXmlConnection* connection);
};

</STRUCT>
<STRUCT>
<NAME>InfdSessionProxy</NAME>
struct _InfdSessionProxy {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>infd_session_proxy_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_session_proxy_get_session</NAME>
<RETURNS>InfSession *</RETURNS>
InfdSessionProxy* proxy
</FUNCTION>
<FUNCTION>
<NAME>infd_session_proxy_add_user</NAME>
<RETURNS>InfUser *</RETURNS>
InfdSessionProxy* proxy,const GParameter* params,guint n_params,GError** error
</FUNCTION>
<FUNCTION>
<NAME>infd_session_proxy_subscribe_to</NAME>
<RETURNS>void </RETURNS>
InfdSessionProxy* proxy,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>infd_session_proxy_has_subscriptions</NAME>
<RETURNS>gboolean </RETURNS>
InfdSessionProxy* proxy
</FUNCTION>
<FUNCTION>
<NAME>infd_session_proxy_is_subscribed</NAME>
<RETURNS>gboolean </RETURNS>
InfdSessionProxy* proxy,InfXmlConnection* connection
</FUNCTION>
<FUNCTION>
<NAME>infd_session_proxy_is_idle</NAME>
<RETURNS>gboolean </RETURNS>
InfdSessionProxy* proxy
</FUNCTION>
<MACRO>
<NAME>INFD_TYPE_FILESYSTEM_STORAGE</NAME>
#define INFD_TYPE_FILESYSTEM_STORAGE                 (infd_filesystem_storage_get_type())
</MACRO>
<MACRO>
<NAME>INFD_FILESYSTEM_STORAGE</NAME>
#define INFD_FILESYSTEM_STORAGE(obj)                 (G_TYPE_CHECK_INSTANCE_CAST((obj), INFD_TYPE_FILESYSTEM_STORAGE, InfdFilesystemStorage))
</MACRO>
<MACRO>
<NAME>INFD_FILESYSTEM_STORAGE_CLASS</NAME>
#define INFD_FILESYSTEM_STORAGE_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), INFD_TYPE_FILESYSTEM_STORAGE, InfdFilesystemStorageClass))
</MACRO>
<MACRO>
<NAME>INFD_IS_FILESYSTEM_STORAGE</NAME>
#define INFD_IS_FILESYSTEM_STORAGE(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), INFD_TYPE_FILESYSTEM_STORAGE))
</MACRO>
<MACRO>
<NAME>INFD_IS_FILESYSTEM_STORAGE_CLASS</NAME>
#define INFD_IS_FILESYSTEM_STORAGE_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), INFD_TYPE_FILESYSTEM_STORAGE))
</MACRO>
<MACRO>
<NAME>INFD_FILESYSTEM_STORAGE_GET_CLASS</NAME>
#define INFD_FILESYSTEM_STORAGE_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS((obj), INFD_TYPE_FILESYSTEM_STORAGE, InfdFilesystemStorageClass))
</MACRO>
<MACRO>
<NAME>INFD_TYPE_FILESYSTEM_STORAGE_ITER</NAME>
#define INFD_TYPE_FILESYSTEM_STORAGE_ITER            (infd_filesystem_storage_iter_get_type())
</MACRO>
<STRUCT>
<NAME>InfdFilesystemStorage</NAME>
</STRUCT>
<STRUCT>
<NAME>InfdFilesystemStorageClass</NAME>
</STRUCT>
<ENUM>
<NAME>InfdFilesystemStorageError</NAME>
typedef enum _InfdFilesystemStorageError {
  /* The path contains invalid characters */
  INFD_FILESYSTEM_STORAGE_ERROR_INVALID_PATH,

  INFD_FILESYSTEM_STORAGE_ERROR_FAILED
} InfdFilesystemStorageError;
</ENUM>
<STRUCT>
<NAME>InfdFilesystemStorageClass</NAME>
struct _InfdFilesystemStorageClass {
  GObjectClass parent_class;
};

</STRUCT>
<STRUCT>
<NAME>InfdFilesystemStorage</NAME>
struct _InfdFilesystemStorage {
  GObject parent;
};

</STRUCT>
<FUNCTION>
<NAME>infd_filesystem_storage_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>infd_filesystem_storage_new</NAME>
<RETURNS>InfdFilesystemStorage *</RETURNS>
const gchar* root_directory
</FUNCTION>
<FUNCTION>
<NAME>infd_filesystem_storage_open</NAME>
<RETURNS>FILE *</RETURNS>
InfdFilesystemStorage* storage,const gchar* identifier,const gchar* path,const gchar* mode,GError** error
</FUNCTION>
